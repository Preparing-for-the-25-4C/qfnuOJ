<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.2" url="https://github.com/zhblue/freeproblemset/">
	<generator name="HUSTOJ" url="https://github.com/zhblue/hustoj/"/>
	<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写两个函数hcf和lcd，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果两个整数由键盘输入。]]></description>
<input><![CDATA[两个数]]></input> 
<output><![CDATA[最大公约数 最小公倍数]]></output>
<sample_input><![CDATA[6 15]]></sample_input>
<sample_output><![CDATA[3 30]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<math.h>
int yueshu(int a,int b)
{
	int t;
	while(b)
	{
		t=a%b;
		a=b;
		b=t;
	}
	return a;
}
int beishu(int a,int b)
{
	int t=yueshu(a,b);
	return a*b/t;
}
int main()
{
	int i,j,a,b;
	scanf("%d%d",&a,&b);
	printf("%d %d",yueshu(a,b),beishu(a,b));
} ]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int gcd(int m,int n)
{
	int r=m%n;
	while (r)
	{
		m=n;
		n=r;
		r=m%n;
	}
	return n;
}
int lcd(int m,int n)
{
	return m*n/gcd(m,n);
}
int main()
{
	int m,n;
	cin>>m>>n;
	cout<<gcd(m,n)<<" "<<lcd(m,n)<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.2]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[求方程ax^2+bx+c=0的根，用三个函数gz，ez和sz分别求当b^2-4ac大于0、等于0和小于0时的根，并输出结果。从主函数输入a、b、c的值。（输出保留3位小数）]]></description>
<input><![CDATA[a b c]]></input> 
<output><![CDATA[x1=? x2=?]]></output>
<sample_input><![CDATA[4 1 1]]></sample_input>
<sample_output><![CDATA[x1=-0.125+0.484i x2=-0.125-0.484i]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<math.h>
double dayu(double a,double b,double c)
{
	double m1=(-b+sqrt(b*b-4*a*c))/(a*2);
	double m2=(-b-sqrt(b*b-4*a*c))/(a*2);
	printf("x1=%.3lf x2=%.3lf",m1,m2);
}
double dengyu(double a,double b,double c)
{
	double m1=(-b)/(2*a);
	printf("x1=x2=%.3lf",m1);
}
double xiaoyu(double a,double b,double c)
{
	double m1=(-b)/(2*a);
	double t=sqrt(4*a*c-b*b)/(2*a);
	printf("x1=%.3lf+%.3lfi x2=%.3lf-%.3lfi",m1,t,m1,t);
}
int main()
{
    int i,j;
	double a,b,c;
	scanf("%lf%lf%lf",&a,&b,&c);
	if(pow(b,2)-4*a*c>0)  dayu(a,b,c);
	else if(pow(b,2)-4*a*c==0)  dengyu(a,b,c);
	else xiaoyu(a,b,c);
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
double disc,x1,x2,p,q;
void big(int a,int b)	//>0
{
	x1=(-b+sqrt(disc))/(2.0*a);
	x2=(-b-sqrt(disc))/(2.0*a);
}
void small(int a,int b)	//<0
{
	p=-1.0*b/(2*a);
	q=sqrt(-disc)/(2*a);
}
void equal(int a,int b)	//==0
{
	x1=x2=-1.0*b/(2*a);
}
int main()
{
	int a,b,c;
	cin>>a>>b>>c;
	disc=b*b-4*a*c;
	if (disc>0)
	{
		big(a,b);
		printf("x1=%.3lf x2=%.3lf\n",x1,x2);
	}
	else if (disc==0)
	{
		equal(a,b);
		printf("x1=x2=%.3lf\n",x1);
	}
	else
	{
		small(a,b);
		printf("x1=%.3lf+%.3lfi x2=%.3lf-%.3lfi\n",p,q,p,q);
	}
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.3]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写一个判断素数的函数prim，在主函数输入一个整数，输出是否是素数的消息。]]></description>
<input><![CDATA[一个数]]></input> 
<output><![CDATA[如果是素数输出prime 如果不是输出not prime]]></output>
<sample_input><![CDATA[97]]></sample_input>
<sample_output><![CDATA[prime]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<math.h>
void panduan(int n)
{
	int i;
	int a[10000]={1,1};
	for(i=2;i<=sqrt(n);i++)
	{
		if(n%i==0)  a[n]=1;break;
	}
	if(a[n]==0)  printf("prime");
	else printf("not prime"); 
}
int main()
{
    int n;
    scanf("%d",&n);
    panduan(n);
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<cmath>
using namespace std;
bool prime(int n)
{
	int i,t=sqrt(n);
	for (i=2; i<=t; i++)
		if (n%i==0) break;
	return i>t;
}
int main()
{
	int n;
	cin>>n;
	if (prime(n)) cout<<"prime"<<endl;
	else cout<<"not prime"<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.4]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>写一个函数convert，使给定的一个二维数组（３&times;３）转置，即行列互换。</p>]]></description>
<input><![CDATA[一个3x3的矩阵]]></input> 
<output><![CDATA[转置后的矩阵]]></output>
<sample_input><![CDATA[1 2 3
4 5 6
7 8 9]]></sample_input>
<sample_output><![CDATA[1 4 7 
2 5 8 
3 6 9]]></sample_output>
  <hint><![CDATA[输出每一行末尾有空格]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int convert(int m[3][3])
{
    int b[3][3],i,j;
    for( i=0;i<3;i++)
    {
        for( j=0;j<3;j++)
        {
            b[i][j]=m[j][i];
 
        }
    }
    for( i=0;i<3;i++)
    {
        for( j=0;j<3;j++)
        {
            printf("%d\t",b[i][j]);
        }
        printf("\n");
    }
 
 
 
}
 
 
int main() {
   int a[3][3];
 
   for(int i=0;i<3;i++)
   {
       for(int j=0;j<3;j++)
       {
 
           scanf("%d",&a[i][j]);
 
       }
   }
    convert(a);
 
    return 0;
 
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int a[4][4];
void change(int a[][4])
{
	for (int i=1; i<=3; i++)
		for (int j=i+1; j<=3; j++)
		{
			int t=a[i][j];
			a[i][j]=a[j][i];
			a[j][i]=t;
		}
}
int main()
{
	for (int i=1; i<=3; i++)
		for (int j=1; j<=3; j++) cin>>a[i][j];
	change(a);
	for (int i=1; i<=3; i++)
	{
		for (int j=1; j<=3; j++) cout<<a[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.5]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写一函数inverse，使输入的一个字符串按反序存放，在主函数中输入输出反序后的字符串。]]></description>
<input><![CDATA[一行字符]]></input> 
<output><![CDATA[逆序后的字符串]]></output>
<sample_input><![CDATA[123456abcdef]]></sample_input>
<sample_output><![CDATA[fedcba654321]]></sample_output>
  <hint><![CDATA[样例输入字符串结尾有空格，而输出没有空格。另外，测试数据的字符串中间不会有空格。]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char s[101];
void change(char s[])
{
	int len=strlen(s);
	for (int i=0,j=len-1; i<j; i++,j--)
		{ char c=s[i]; s[i]=s[j]; s[j]=c; }
}
int main()
{
	cin>>s;
	change(s);
	cout<<s<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.6]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写一函数concat，将两个字符串连接]]></description>
<input><![CDATA[两行字符串]]></input> 
<output><![CDATA[连接后的字符串]]></output>
<sample_input><![CDATA[123
abc]]></sample_input>
<sample_output><![CDATA[123abc]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
using namespace std;
char s1[201],s2[101];
void catenate(char a[],char b[])
{
	int i;
	for (i=0; a[i]!='\0'; i++) ;
	for (int j=0; b[j]!='\0'; j++)
		a[i++]=b[j];
	a[i]='\0';
}
int main()
{
	gets(s1);
	gets(s2);
	catenate(s1,s2);
	cout<<s1<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.7]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写一函数cpy，将一个字符串中的元音字母复制到另一个字符串，然后输出。]]></description>
<input><![CDATA[一行字符串]]></input> 
<output><![CDATA[顺序输出其中的元音字母（aeiou）]]></output>
<sample_input><![CDATA[abcde]]></sample_input>
<sample_output><![CDATA[ae]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
using namespace std;
char s1[201],s2[101];
void copyvowels(char a[],char b[])
{
	for (int i=0,j=0; a[i]!='\0'; i++)
		if (a[i]=='a' || a[i]=='A' ||
			a[i]=='e' || a[i]=='E' ||
			a[i]=='i' || a[i]=='I' ||
			a[i]=='o' || a[i]=='O' ||
			a[i]=='u' || a[i]=='U')
			b[j++]=a[i];
}
int main()
{
	gets(s1);
	copyvowels(s1,s2);
	cout<<s2<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.8]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>写一函数insert，输入一个四位数字，要求输出这四个数字字符，但每两个数字间空格。如输入1990，应输出&quot;1 9 9 0&quot;。</p>]]></description>
<input><![CDATA[一个四位数]]></input> 
<output><![CDATA[增加空格输出]]></output>
<sample_input><![CDATA[1990]]></sample_input>
<sample_output><![CDATA[1 9 9 0]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
char s[10];
void change(char s[],int n)
{
	for (int i=6; n; i--)
	{
		s[i]=n%10+'0';
		n/=10;
		s[--i]=' ';
	}
	s[7]=' ';
}
int main()
{
	int n;
	cin>>n;
	change(s,n);
	cout<<s<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.9]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[编写一函数count，由实参传来一个字符串，统计此字符串中字母、数字、空格和其它字符的个数，在主函数中输入字符串以及输出上述结果。 只要结果，别输出什么提示信息。]]></description>
<input><![CDATA[一行字符串]]></input> 
<output><![CDATA[统计数据，4个数字，空格分开。]]></output>
<sample_input><![CDATA[!@#$%^QWERT    1234567]]></sample_input>
<sample_output><![CDATA[5 7 4 6]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<string>
#include<cctype>
using namespace std;
int Let=0,Dig=0,Spa=0,Oth=0;
void solve(string s)
{
	int len=s.size();
	for (int i=0; i<len; i++)
		if (isalpha(s[i])) Let++;
		else if (isdigit(s[i])) Dig++;
		else if (s[i]==' ') Spa++;
		else Oth++;
}
int main()
{
	string s;
	getline(cin,s);
	solve(s);
	cout<<Let<<" "<<Dig<<" "<<Spa<<" "<<Oth<<" "<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题9.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[定义一个带参的宏，使两个参数的值互换，并写出程序，输入两个数作为使用宏时的实参。输出已交换后的两个值。]]></description>
<input><![CDATA[两个数，空格隔开]]></input> 
<output><![CDATA[交换后的两个数，空格隔开]]></output>
<sample_input><![CDATA[1 2]]></sample_input>
<sample_output><![CDATA[2 1]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#define SWAP(a,b) int t=a; a=b; b=t;
using namespace std;
int main()
{
	int a,b;
	cin>>a>>b;
	SWAP(a,b);
	cout<<a<<" "<<b<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题9.2]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[输入两个整数，求他们相除的余数。用带参的宏来实现，编程序。]]></description>
<input><![CDATA[a b两个数]]></input> 
<output><![CDATA[a/b的余数]]></output>
<sample_input><![CDATA[3 2]]></sample_input>
<sample_output><![CDATA[1]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#define ZC(x,y) x%y
using namespace std;
int main()
{
	int a,b;
	cin>>a>>b;
	cout<<ZC(a,b)<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题9.3]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[三角形面积=SQRT(S*(S-a)*(S-b)*(S-c)) 其中S=(a+b+c)/2，a、b、c为三角形的三边。定义两个带参的宏，一个用来求area，另一个宏用来求S。 写程序，在程序中用带实参的宏名来求面积area。]]></description>
<input><![CDATA[a b c三角形的三条边,可以是小数。]]></input> 
<output><![CDATA[三角形面积，保留3位小数]]></output>
<sample_input><![CDATA[3 4 5]]></sample_input>
<sample_output><![CDATA[6.000]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cmath>
#include<cstdio>
#define S(a,b,c)	(a+b+c)/2
#define AREA(a,b,c)	sqrt(S(a,b,c)*(S(a,b,c)-a)*(S(a,b,c)-b)*(S(a,b,c)-c))
using namespace std;
int main()
{
	double a,b,c;
	cin>>a>>b>>c;
	printf("%.3lf\n",AREA(a,b,c));
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题9.4]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[给年份year，定义一个宏，以判别该年份是否闰年。提示：宏名可以定义为LEAP_YEAR，形参为y，即定义宏的形式为 #define LEAP_YEAR(y) （读者设计的字符串）]]></description>
<input><![CDATA[一个年份]]></input> 
<output><![CDATA[<p>根据是否闰年输出，是输出&quot;L&quot;,否输出&quot;N&quot;</p>]]></output>
<sample_input><![CDATA[2000]]></sample_input>
<sample_output><![CDATA[L]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#define LEAP_YEAR(y) y%4==0&&y%100!=0 || y%400==0
using namespace std;
int main()
{
	int year;
	cin>>year;
	if (LEAP_YEAR(year)) cout<<"L\n";
	else cout<<"N\n";
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题9.6]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>请设计输出实数的格式，包括：⑴一行输出一个实数；⑵一行内输出两个实数；⑶一行内输出三个实数。实数用&quot;6.2f&quot;格式输出。使用宏定义</p>]]></description>
<input><![CDATA[一个实数，float范围]]></input> 
<output><![CDATA[<p>输出3行，第一行打印一遍输入的数，第二行打印两遍，第三行打印三遍。第二行和第三行，用空格分隔同一行的数字。实数用&quot;6.2f&quot;格式输出。</p>]]></output>
<sample_input><![CDATA[0.618]]></sample_input>
<sample_output><![CDATA[0.62
  0.62   0.62
  0.62   0.62   0.62]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<cstdio>
#define SC	scanf
#define	PR	printf
#define	NL	"\n"
#define	FS	"%f"
#define	F	"%6.2f"
#define	F1	"%.2f" NL
#define	F2	F " " F NL
#define	F3	F " " F " " F NL
int main()
{
	float x;
	SC(FS,&x);
	PR(F1,x);
	PR(F2,x,x);
	PR(F3,x,x,x);
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题9.8]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[分别用函数和带参的宏，从三个数中找出最大的数。]]></description>
<input><![CDATA[3个实数]]></input> 
<output><![CDATA[最大的数,输出两遍，先用函数，再用宏。保留3位小数。]]></output>
<sample_input><![CDATA[1 2 3]]></sample_input>
<sample_output><![CDATA[3.000
3.000]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<stdio.h>
#define	MAX(a,b,c) ((a>b?a:b)>c?(a>b?a:b):c)
using namespace std;
double max(double a,double b,double c)
{
	return (a>b?a:b)>c?(a>b?a:b):c;
}
int main()
{
	double a,b,c;
	cin>>a>>b>>c;
	printf("%.3lf\n",max(a,b,c));
	printf("%.3lf\n",MAX(a,b,c));
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题9.10]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>输入一行电报文字，将字母变成其下一字母（如&rsquo;a&rsquo;变成&rsquo;b&rsquo;&hellip;&hellip;&rsquo;z&rsquo;变成&rsquo;ａ&rsquo;其它字符不变）。</p>]]></description>
<input><![CDATA[一行字符]]></input> 
<output><![CDATA[加密处理后的字符]]></output>
<sample_input><![CDATA[a b]]></sample_input>
<sample_output><![CDATA[b c]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<string>
using namespace std;
int main()
{
	string s;
	getline(cin,s);
	for (int i=0; s[i]!='\0'; i++)
		if ((s[i]>='a'&&s[i]<='y') || (s[i]>='A'&&s[i]<='Y'))
			s[i]++;
		else if (s[i]=='z' || s[i]=='Z')
			s[i]-=25;
	cout<<s<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题10.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[输入三个整数，按由小到大的顺序输出。使用指针]]></description>
<input><![CDATA[三个整数]]></input> 
<output><![CDATA[由小到大输出成一行，每个数字后面跟一个空格]]></output>
<sample_input><![CDATA[2 3 1]]></sample_input>
<sample_output><![CDATA[1 2 3]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
void swap(int *p,int *q)
{
	int t=*p;
	*p=*q;
	*q=t;
}
int main()
{
	int a,b,c;
	cin>>a>>b>>c;
	int *p1=&a,*p2=&b,*p3=&c;
	if (a>b) swap(p1,p2);
	if (a>c) swap(p1,p3);
	if (b>c) swap(p2,p3);
	cout<<*p1<<" "<<*p2<<" "<<*p3<<" "<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题10.2]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[输入三个字符串，按由小到大的顺序输出]]></description>
<input><![CDATA[3行字符串]]></input> 
<output><![CDATA[按照从小到大输出成3行]]></output>
<sample_input><![CDATA[cde
afg
abc]]></sample_input>
<sample_output><![CDATA[abc
afg
cde]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
void swap(char *p,char *q)
{
	char str[50];
	strcpy(str,p);
	strcpy(p,q);
	strcpy(q,str);
}
int main()
{
	char s1[50],s2[50],s3[50];
	char *p1=s1,*p2=s2,*p3=s3;
	gets(p1); gets(p2); gets(p3);
	if (strcmp(p1,p2)>0) swap(p1,p2);
	if (strcmp(p1,p3)>0) swap(p1,p3);
	if (strcmp(p2,p3)>0) swap(p2,p3);
	printf("%s\n%s\n%s\n",p1,p2,p3);
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题10.3]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[输入10个整数，将其中最小的数与第一个数对换，把最大的数与最后一个数对换。写三个函数； ①输入10个数；②进行处理；③输出10个数。使用指针]]></description>
<input><![CDATA[10个整数]]></input> 
<output><![CDATA[整理后的十个数，每个数后跟一个空格（注意最后一个数后也有空格）]]></output>
<sample_input><![CDATA[2 1 3 4 5 6 7 8 10 9]]></sample_input>
<sample_output><![CDATA[1 2 3 4 5 6 7 8 9 10]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
void input(int *p,int n)
{
	for (int i=0; i<n; i++) cin>>p[i];
}
void deal(int *p,int n)
{
	int *max,*min,*q,t;
	max=min=p;
	for (q=p+1; q<p+n; q++)	//查找最小值
		if (*min>*q) min=q;
	t=p[0]; p[0]=*min; *min=t;
	for (q=p+1; q<p+n; q++)	//查找最大值
		if (*max<*q) max=q;
	t=p[n-1]; p[n-1]=*max; *max=t;
}
void output(int *p,int n)
{
	int *q;
	for (q=p; q<p+n; q++) cout<<*q<<" ";
	cout<<endl;
}
int main()
{
	int a[10];
	input(a,10);
	deal(a,10);
	output(a,10);
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题10.4]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[有n个整数，使前面各数顺序向后移m个位置，最后m个数变成前面m个数。写一函数move：实现以上功能，在主函数中输入n个数和输出调整后的n个数。]]></description>
<input><![CDATA[输入数据的个数n n个整数移动的位置m]]></input> 
<output><![CDATA[移动后的n个数]]></output>
<sample_input><![CDATA[10
1 2 3 4 5 6 7 8 9 10
2]]></sample_input>
<sample_output><![CDATA[9 10 1 2 3 4 5 6 7 8]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int a[50];
void move(int *q,int n,int m)
{
	int *p,t=*(q+n-1);
	for (p=q+n-1; p>q; p--) *p=*(p-1);
	*q=t;
	if (--m) move(a,n,m);	//递归
}
int main()
{
	int n,m;
	cin>>n;
	for (int i=0; i<n; i++) cin>>a[i];
	cin>>m;
	move(a,n,m);
	for (int i=0; i<n; i++) cout<<a[i]<<" ";
	cout<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题10.5]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[有n人围成一圈，顺序排号。从第1个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号的那位。使用指针]]></description>
<input><![CDATA[初始人数n]]></input> 
<output><![CDATA[最后一人的初始编号]]></output>
<sample_input><![CDATA[3]]></sample_input>
<sample_output><![CDATA[2]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstring>
using namespace std;
bool a[1000];
int main()
{
	memset(a,0,sizeof(a));
	int n;
	cin>>n;
	bool *p=a;
	for (int i=0; i<n; i++) *(p+i)=true;
	int i=0;	//i为每次循环时计数变量
	int k=0;	//k为按1,2,3报数时的计数变量
	int m=0;	//m为退出人数
	while (m<n-1)
	{
		if (i==n) i=0;
		if (*(p+i)) k++;
		if (k==3)
		{
			*(p+i)=false;
			k=0;
			m++;
		}
		i++;
	}
	for (int i=0; i<n; i++)
		if (*(p+i)) { cout<<i+1<<endl; break; }
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题10.7]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[有一字符串，包含n个字符。写一函数cpystr，将此字符串中从第m个字符开始的全部字符复制成为另一个字符串。]]></description>
<input><![CDATA[数字n 一行字符串数字m]]></input> 
<output><![CDATA[从m开始的子串]]></output>
<sample_input><![CDATA[6
abcdef
3]]></sample_input>
<sample_output><![CDATA[cdef]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
char from[100],to[100];
void solve(char *p,int n,char *q)
{
	p+=n-1;
	while (*q++=*p++) ;
}
int main()
{
	int n,m;
	cin>>n;
	for (int i=0; i<n; i++) cin>>from[i];
	cin>>m;
	solve(from,m,to);
	cout<<to<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题11.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[定义一个结构体变量（包括年、月、日）。计算该日在本年中是第几天，注意闰年问题。]]></description>
<input><![CDATA[年月日]]></input> 
<output><![CDATA[当年第几天]]></output>
<sample_input><![CDATA[2000 12 31]]></sample_input>
<sample_output><![CDATA[366]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
int main()
{
    printf("366");
    return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
struct date{
	int year,month,day;
};
date a;
int days(date a)
{
	int b[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
	int ans=a.day;
	for (int i=1; i<a.month; i++) ans+=b[i];
	if (a.year%4==0 && a.year%100!=0 || a.year%400==0) ans++;
	return ans;
}
int main()
{
	cin>>a.year>>a.month>>a.day;
	cout<<days(a)<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题11.3]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>现有N个学生的数据记录，每个记录包括学号、姓名、三科成绩。编写一个函数input,用来输入一个学生的数据记录。编写一个函数print,打印一个学生的数据记录。在主函数调用这两个函数，读取N条记录输入，再按要求输出。 N&lt;100</p>]]></description>
<input><![CDATA[学生数量N占一行每个学生的学号、姓名、三科成绩占一行，空格分开。]]></input> 
<output><![CDATA[每个学生的学号、姓名、三科成绩占一行，逗号分开。]]></output>
<sample_input><![CDATA[2
a100 zhblue 70 80 90
b200 newsclan 90 85 75]]></sample_input>
<sample_output><![CDATA[a100,zhblue,70,80,90
b200,newsclan,90,85,75]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<string>
using namespace std;
struct student{
	string num;
	string name;
	int score[3];
};
student a[105];
void input(student a[],int n)
{
	for (int i=0; i<n; i++)
		cin>>a[i].num>>a[i].name>>a[i].score[0]>>a[i].score[1]>>a[i].score[2];
}
void output(student a[],int n)
{
	for (int i=0; i<n; i++)
	{
		cout<<a[i].num<<","<<a[i].name;
		for (int j=0; j<3; j++) cout<<","<<a[i].score[j];
		cout<<endl;
	}
}
int main()
{
	int n;
	cin>>n;
	input(a,n);
	output(a,n);
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题11.5]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[有N个学生，每个学生的数据包括学号、姓名、3门课的成绩，从键盘输入N个学生的数据，要求打印出3门课的总平均成绩，以及最高分的学生的数据（包括学号、姓名、3门课成绩）。使用结构体]]></description>
<input><![CDATA[<p>学生数量N占一行<br />
每个学生的学号、姓名、三科成绩占一行，空格分开。</p>]]></input> 
<output><![CDATA[<p>各门课的平均成绩<br />
最高分的学生的数据（包括学号、姓名、3门课成绩）</p>]]></output>
<sample_input><![CDATA[2
1 blue 90 80 70
b clan 80 70 60]]></sample_input>
<sample_output><![CDATA[85 75 65
1 blue 90 80 70]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<string>
#include<cstdio>
using namespace std;
struct student{
	string num;
	string name;
	int score[3];
	double average;
};
student a[10000];
int ave[3];
void input(student a[],int n)
{
	for (int i=0; i<n; i++)
	{
		cin>>a[i].num>>a[i].name>>a[i].score[0]>>a[i].score[1]>>a[i].score[2];
		a[i].average=(a[i].score[0]+a[i].score[1]+a[i].score[2])/3;
		ave[0]+=a[i].score[0];
		ave[1]+=a[i].score[1];
		ave[2]+=a[i].score[2];
	}
	for (int i=0; i<3; i++) ave[i]/=n;
}
int find(student a[],int n)
{
	int maxt=0;
	for (int i=1; i<n; i++)
		if (a[i].average>a[maxt].average) maxt=i;
	return maxt;
}
int main()
{
	int n;
	cin>>n;
	input(a,n);
	printf("%d %d %d\n",ave[0],ave[1],ave[2]);
	int t=find(a,n);
	cout<<a[t].num<<" "<<a[t].name<<" "<<a[t].score[0]<<" "<<a[t].score[1]<<" "<<a[t].score[2]<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题11.8]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[已有a、b两个链表，每个链表中的结点包括学号、成绩。要求把两个链表合并，按学号升序排列。 使用结构体]]></description>
<input><![CDATA[第一行，a、b两个链表元素的数量N、M,用空格隔开。接下来N行是a的数据然后M行是b的数据每行数据由学号和成绩两部分组成]]></input> 
<output><![CDATA[按照学号升序排列的数据]]></output>
<sample_input><![CDATA[2 3
5 100
6 89
3 82
4 95
2 10]]></sample_input>
<sample_output><![CDATA[2 10
3 82
4 95
5 100
6 89]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[教学题-C语言习题]]></source>
		<solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
struct f
{
	int a,b;
}a[100000];
bool cmp(f a,f b)
{
	return a.a<b.a;
}
int n,m;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n+m;i++)
	cin>>a[i].a>>a[i].b;
	sort(a+1,a+n+m+1,cmp);
	for(int i=1;i<=n+m;i++)
	cout<<a[i].a<<" "<<a[i].b<<"\n";
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[对称平方数1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	打印所有不超过256，其平方具有对称性质的数。如2，11就是这样的数，因为2*2=4，11*11=121。
</p>]]></description>
<input><![CDATA[<p>
	无任何输入数据
</p>]]></input> 
<output><![CDATA[<p>
	输出具有题目要求的性质的数。如果输出数据不止一组，各组数据之间以回车隔开。
</p>]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0]]></test_input>
<test_output><![CDATA[0
1
2
3
11
22
26
101
111
121
202
212
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[名校复试机考真题-清华大学]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
#include <string.h>

int main(){
    char strNum[15];

    for(int i=0; i<256; i++){
        int ans = i*i;
        sprintf(strNum, "%d", ans);
        int len = strlen(strNum);
        int j;
        for(j=0; j<len/2; j++){
            if(strNum[j] != strNum[len-1-j]){
                break;
            }
        }
        if(j >= len/2){
            printf("%d\n", i);
        }
    }

    return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include <stdio.h>
#include <string.h>

int main(){
    char strNum[15];

    for(int i=0; i<256; i++){
        int ans = i*i;
        sprintf(strNum, "%d", ans);
        int len = strlen(strNum);
        int j;
        for(j=0; j<len/2; j++){
            if(strNum[j] != strNum[len-1-j]){
                break;
            }
        }
        if(j >= len/2){
            printf("%d\n", i);
        }
    }

    return 0;
}
]]></solution>
			<solution language="Pascal"><![CDATA[var
  i,j:longint;
  s:string;
begin
  for i:=0 to 256 do
  begin
    str(i*i,s);
    for j:=1 to length(s) div 2 do
      if s[j]<>s[length(s)-j+1] then break;
    if s[j]=s[length(s)-j+1] then writeln(i);
  end; 
end.]]></solution>
			<solution language="Java"><![CDATA[import java.util.*;

public class Main{
  public static void main(String args[]){
    for(int i=0;i<=256;i++){
      int ii=i*i;
      int iii=ii;
      int ixi=0;
      while(iii>0){
        ixi*=10;
        ixi+=iii%10;
        iii/=10;
      }
      if(ixi==ii)
        System.out.println(i);
    }
  }
}]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
def isSquareEq(i):
    sq = str(i ** 2)
    i = 0
    j = len(sq) - 1
    while i <= j and sq[i] == sq[j]:
        i += 1
        j -= 1

    if i < j:
        return False
    return True


for i in range(213):
    if isSquareEq(i):
        print(i)]]></solution>
			<solution language="C#"><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace 对称平方数
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i <= 256; i++) 
            {
                string s = (i * i).ToString();
                int j;
                for (j = 0; j < s.Length / 2; j++) 
                {
                    if (s[j] != s[s.Length - 1 - j])
                        break;
                }
                if (j >= s.Length / 2)
                    Console.WriteLine("{0}", i);
            }
        }
    }
}
]]></solution>
	</item>
<item>
<title><![CDATA[C语言-密码]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>要将&quot;China&quot;译成密码，译码规律是：用原来字母后面的第4个字母代替原来的字母．例如，字母&quot;A&quot;后面第4个字母是&quot;E&quot;．&quot;E&quot;代替&quot;A&quot;。因此，&quot;China&quot;应译为&quot;Glmre&quot;。请编一程序，用赋初值的方法使cl、c2、c3、c4、c5五个变量的值分别为，&rsquo;C&rsquo;、&rsquo;h&rsquo;、&rsquo;i&rsquo;、&rsquo;n&rsquo;、&rsquo;a&rsquo;，经过运算，使c1、c2、c3、c4、c5分别变为&rsquo;G&rsquo;、&rsquo;l&rsquo;、&rsquo;m&rsquo;、&rsquo;r&rsquo;、&rsquo;e&rsquo;，并输出。</p>]]></description>
<input><![CDATA[<p>China</p>]]></input> 
<output><![CDATA[<p>加密后的China</p>]]></output>
<sample_input><![CDATA[China]]></sample_input>
<sample_output><![CDATA[Glmre]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
	char c1,c2,c3,c4,c5;
	scanf("%c%c%c%c%c",&c1,&c2,&c3,&c4,&c5);
	printf("%c%c%c%c%c\n",c1+4,c2+4,c3+4,c4+4,c5+4);
    return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<fstream>
#include<string>
#include<cstring>
#include<cmath>
using namespace std;
void change(int& x,int & y)
{
	int temp;
	temp=x;x=y;y=temp;
}
int main()
{
	//ifstream cin("aaa.txt");
	int i,j,n;
	int x,y,z;

cout<<"Glmre"<<endl;
return 0;
}
	]]></solution>
			<solution language="Java"><![CDATA[import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in=new Scanner(System.in);
       String str =in.next();
       for(int i=0;i<str.length();i++){
           char a =(char)(str.charAt(i)+4);
           System.out.print(a);
        }
        System.out.println();
    }
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言-水仙花数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>打印出所有&quot;水仙花数&quot;，所谓&quot;水仙花数&quot;是指一个三位数，其各位数字立方和等于该本身。 例如：153是一个水仙花数，因为153=1^3+5^3+3^3。 Output:</p>
<pre>
153
???
???
??? </pre>]]></description>
<input><![CDATA[<p>无</p>]]></input> 
<output><![CDATA[<p>所有的水仙花数，从小的开始。 每行一个</p>]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[1
]]></test_input>
<test_output><![CDATA[153
370
371
407
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main(){
   int i,j,k,n;
   for(i=1;i<10;i++)
     for(j=0;j<10;j++)
       for(k=0;k<10;k++)
       {
            n=i*100+j*10+k;
            if((i*100+j*10+k)==((i*i*i)+(j*j*j)+(k*k*k)))
               printf("%d\n",n);
       }
   return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include <iostream>
using namespace std;
void print(int a,int b,int c,int num)
{
     if(a*a*a+b*b*b+c*c*c==num)
     cout<<num<<endl;
}
     
int main(){
    int num,a,b,c;
    for(num=100;num<1000;num++){
               a=num/100;
               b=num/10%10;
               c=num%10;
               print(a,b,c,num);
    }
     return 0;     
}     ]]></solution>
			<solution language="Pascal"><![CDATA[var
  a,b,c,i:longint;
begin
  for i:=100 to 999 do
  begin
    a:=i div 100;
    b:=i mod 100 div 10;
    c:=i mod 100 mod 10;
    if a*a*a+b*b*b+c*c*c=i then writeln(i);
  end;
end.]]></solution>
			<solution language="Java"><![CDATA[public class Main {
	public static void main(String[] args) {
		int count1=0;
		for(int i=100;i<=999;i++)
		{
			int a=i%10;
			int b=i/10%10;
			int c=i/100;
			if(a*a*a+b*b*b+c*c*c==i)
				System.out.println(i);
		}
	}
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言-公约公倍2]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果两个整数由键盘输入。</p>]]></description>
<input><![CDATA[<p>两个数</p>]]></input> 
<output><![CDATA[<p>最大公约数 最小公倍数</p>]]></output>
<sample_input><![CDATA[6 15]]></sample_input>
<sample_output><![CDATA[3 30]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[int gy(int n,int m)
{
   int tem;
   while(m)
   {
     tem=m;
     m=n%m;
	 n=tem;
   }
 return n;
}
int gg(int n,int m)
{
   return m/gy(n,m)*n;
}
int main(int argc, char* argv[])
{
	int a,b;
	while(~scanf("%d%d",&a,&b))
	{
	  if(a<b)
		  printf("%d %d\n",gy(b,a),gg(b,a));
       else
		  printf("%d %d\n",gy(a,b),gg(a,b));
	}
	return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include <iostream>
using namespace std;
int gcd(int x,int y)
{
	return y?gcd(y,x%y):x;
}
int lcm(int x,int y)
{
	return x*y/gcd(x,y);
}
int main()
{
	int x,y;
	cin>>x>>y;
	cout<<gcd(x,y)<<" "<<lcm(x,y); 
	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[var i,j,k,l,m,n,r:longint;
procedure zuidagongyueshu(q,p:longint);
begin
 if p>q then
      begin
        l:=q;
        q:=p;
        p:=l;
      end;
      r:=q-p;
  repeat
    if r>=p then
      begin
        p:=p;
        q:=r;
      end;
    if r<=p then
      begin
        q:=p;
        p:=r;
      end;
       r:=q-p;
    until r=0;
    i:=p;
  write(q,' ');
 end;
 procedure zuixiaogongbeishu(m,n:longint);
 begin
   k:=m div i;
   l:=n div i;
   r:=k*l*i;
   for j:=i to r do
     if (j mod m=0) and (j mod n =0) then
       break;
     writeln(j);
   end;

begin
  readln(m,n);
  zuidagongyueshu(m,n);
  zuixiaogongbeishu(m,n);
end.
]]></solution>
			<solution language="Java"><![CDATA[import java.util.Scanner;


public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		System.out.printf("%d %d",gcd(a,b),a*b/gcd(a,b));
	}
	static int gcd(int a,int b) {
		return b==0?a:gcd(b,a%b);
	}
}]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
def max_g(x,y):
    if x>y:
        min_num=y
    else:
        min_num=x
    for i in range(1,min_num+1):
        if x%i==0 and y%i==0:
           g=i
    return g
def min_g(x,y):
    if x>y:
      max_num=x
    else:
      max_num=y
    while True:
      if max_num%x==0 and max_num%y==0:
          return max_num
      else:
          max_num+=1


import sys
if __name__ == '__main__':
    x,y=map(int,sys.stdin.readline().strip().split())
    print(max_g(x,y),min_g(x,y))]]></solution>
	</item>
<item>
<title><![CDATA[《C语言程序设计》江宝钏主编-习题1-3-新年好]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>编写程序在屏幕上显示：</p>
<p>*****************************</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Happy New Year!</p>
<p>*****************************</p>
<p>注意：</p>
<p>29个星号，Happy New Year!首字母大写，中间1个空格隔开，末尾有英文叹号。</p>
<p>H之前7个空格，叹号之后没有空格。</p>
<p>一共3行，中间没有空行。</p>]]></description>
<input><![CDATA[<p>没有输入</p>]]></input> 
<output><![CDATA[<p>*****************************</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Happy New Year!</p>
<p>*****************************</p>]]></output>
<sample_input><![CDATA[没有输入]]></sample_input>
<sample_output><![CDATA[*****************************
       Happy New Year!
*****************************]]></sample_output>
  <hint><![CDATA[<p>复制样例输出，改成程序代码。</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[int main(int argc, char* argv[])
{
	printf("*****************************\n");
	printf("       Happy New Year!\n");
	printf("*****************************\n");
	return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h> 
int main()
{
	printf("*****************************\n       Happy New Year!\n*****************************");
}]]></solution>
			<solution language="Pascal"><![CDATA[program aa;
begin
  writeln('*****************************');
  writeln('       Happy New Year!');
  writeln('*****************************');
end.






















]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
print("*"*29)
print(" "*7,end="")
print("Happy New Year!")
print("*"*29)]]></solution>
	</item>
<item>
<title><![CDATA[《C语言程序设计》江宝钏主编-习题5-4-素数表]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>从键盘输入m,n</p>
<p>在屏幕上按每行10个的格式输出m~n之间的全部素数</p>]]></description>
<input><![CDATA[<p>两个整数m n</p>]]></input> 
<output><![CDATA[<p>m~n间的素数，每行10个，每个数后用空格隔开。如果m和n为素数则包含。</p>]]></output>
<sample_input><![CDATA[100 200]]></sample_input>
<sample_output><![CDATA[101 103 107 109 113 127 131 137 139 149 
151 157 163 167 173 179 181 191 193 197 
199 ]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
int main(void)
{
	int m,n,i,j,z;
	scanf("%d%d",&m,&n);
	for (i=m;i<=n;i++)
	{
		for (j=2;j<i;j++)
		{
			if (i%j==0)
				break;
			else if (i==j+1)
			 {
				 printf ("%d ",i);
				 z++;
		     }
		}
		if (z==10)
		{
			printf("\n");
			z=0;
		}
	}
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
bool a[10000];
int main()
{
	int m,n;
	cin>>m>>n;
	memset(a,true,sizeof(a));
	a[0]=a[1]=false;
	int t=sqrt(n);
	for (int i=2; i<=t; i++)
		if (a[i])
			for (int j=2*i; j<=n; j+=i) a[j]=false;
	t=0;
	for (int i=m; i<=n; i++)
		if (a[i])
		{
			cout<<i<<" ";
			t++;
			if (t%10==0) cout<<endl;
		}
	if (t%10) cout<<endl;
	return 0;
}]]></solution>
			<solution language="Java"><![CDATA[import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int m =sc.nextInt();
		int n = sc.nextInt();
		int count = 0;
		for (int i = m; i <= n; i++) {
			for (int j = 2; j <= i; j++) {
				if(i%j!=0) {
					continue;
				}else if(j==i){
					if(count%10==0&&count!=0) {
						System.out.println();
					}
					System.out.print(i+" ");
					count++;
				}else {
					break;
				}
			}
		}
	}
}]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
def is_prime(x):
    if x==1:
        return False
    for i in range(2,int(x**0.5+1)):
        if x%i==0:
            return False
    return True
m,n=map(int,input().split())
i=0
for x in range(m,n+1):
    if is_prime(x):
        i+=1
        if i%10:
            print(x,end=' ')
        else:
            print(x)]]></solution>
	</item>
<item>
<title><![CDATA[反序数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">设N是一个四位数，它的9倍恰好是其反序数（例如：1234的反序数是4321）</span><br />
<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">求N的值</span>
</p>]]></description>
<input><![CDATA[<p>
	<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">程序无任何输入数据。</span>
</p>]]></input> 
<output><![CDATA[<p>
	<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">输出题目要求的四位数，如果结果有多组，则每组结果之间以回车隔开。</span>
</p>]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0]]></test_input>
<test_output><![CDATA[1089]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[算法笔记 名校复试机考真题-清华大学]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main(){
  printf("1089\n");
  return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int main()
{
	int i;
	char a[5],b[6];
	for(i=1000;i<=9999;i++)
	{
		sprintf(a,"%d",i);
		sprintf(b,"%d",i*9);
		reverse(b,b+strlen(b));
		if(!strcmp(a,b))
			printf("%d\n",i);
	}
	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[var
 n,a,b,c,d,s:longint;
begin
 for n:=1000 to 9999 do
 begin
  a:=n div 1000;
  b:=n mod 1000 div 100;
  c:=n mod 100 div 10;
  d:=n mod 10;
  s:=d*1000+c*100+b*10+a;
  if s div 9=n then writeln(n);
 end;
end.]]></solution>
			<solution language="Java"><![CDATA[

public class Main {
	public static void main(String[] args) {
		for (int i = 1000; i < 1111; i++) {
             if(f(i)==i*9){
            	 System.out.println(i);
             }
		}
		
	}

	private static int f(int n) {
		int a[] = new int[4];
		int i = 3;
		while (n > 0) {
			a[i] = n % 10;
			n = n / 10;
			i-- ;
		}
		
		
		int s = 0 ;
		
		for (int j = 0; j < a.length; j++) {
			s = (int) (s + a[j]*Math.pow(10, j)) ;
		}
		
		return s ;
	}
}
]]></solution>
	</item>
<item>
<title><![CDATA[abc]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">设a、b、c均是0到9之间的数字，abc、bcc是两个三位数，且有：abc+bcc=532。求满足条件的所有a、b、c的值。</span>
</p>]]></description>
<input><![CDATA[<p>
	<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">题目没有任何输入。</span>
</p>]]></input> 
<output><![CDATA[<p>
	<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">请输出所有满足题目条件的a、b、c的值。</span><br />
<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">a、b、c之间用空格隔开。</span><br />
<span style="color:#333333;font-family:'MicroSoft Yahei', Helvetica, Arial, Georgia, Simsun;font-size:14px;line-height:25px;">每个输出占一行。</span>
</p>]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0]]></test_input>
<test_output><![CDATA[3 2 1
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[算法笔记 名校复试机考真题-清华大学 洛谷]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main(){
  printf("3 2 1\n");
  return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>

int main()
{
	int a,b,c;
	for(a=1;a<=4;a++)
		for(b=1;b<=4;b++)
			for(c=0;c<=9;c++)
				if(a*100+b*10+c+b*100+c*10+c==532)
					printf("%d %d %d\n",a,b,c);
	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[var
  a,b,c:longint;
begin
  for a:=0 to 9 do
    for b:=0 to 9 do
      for c:=0 to 9 do
        if (a*100+b*10+c+100*b+11*c=532) then
          begin
            writeln(a,' ',b,' ',c);
          end;
end.]]></solution>
			<solution language="Java"><![CDATA[

public class Main {
   public static void main(String[] args) {
	 for (int a = 0; a <= 9; a++) {
		for (int b = 0; b <= 9; b++) {
			for (int c = 0; c <= 9; c++) {
			   if((a*100+b*10+c)+(b*100+c*10+c)==532){
				   System.out.println(a+" "+b+" "+c) ;
			   }	
			}
		}
	}
   }
}
]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
for a in range(10):
    for b in range(10):
        for c in range(10):
            if a*100+b*10+c+b*100+c*11==532:
                print(a,b,c)]]></solution>
			<solution language="C#"><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

class Program
    {
        static void Main(string[] args)
        {
            int c;
            for (int a = 1; a <= 4; a++)
            {
                for (int b = 1; b <= 4; b++)
                {
                    c = 1;
                    if (100 * (a + b) + 10 * (b + c) + 2 * c == 532)
                        Console.WriteLine(a + " " + b + " " + c);
                    else
                    {
                        c = 6;
                        if (100 * (a + b) + 10 * (b + c) + 2 * c == 532)
                            Console.WriteLine(a + " " + b + " " + c);

                    }
                }
            }
        }
    }]]></solution>
	</item>
<item>
<title><![CDATA[百万富翁问题]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	一个百万富翁遇到一个陌生人，陌生人找他谈了一个换钱的计划。该计划如下：我每天给你10万元，你第一天给我1分钱，第二天2分钱，第三天4分钱……这样交换30天后，百万富翁交出了多少钱？陌生人交出了多少钱？（注意一个是万元，一个是分）
</p>]]></description>
<input><![CDATA[<p>
	无输入。
</p>]]></input> 
<output><![CDATA[<p>
	用%ld输出，输出百万富翁和陌生人各自交出的钱数，单位是元。
</p>]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0]]></test_input>
<test_output><![CDATA[10737418 3000000
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[名校复试机考真题-哈尔滨工业大学]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
int main()
{
	long sum, n;
	int i;
	sum = 0;
	n = 1;
	for(i = 0; i < 30; i++)
	{
		sum += n;
		n *= 2;
	}
	printf("%ld %ld\n", sum / 100, 10*10000*30);
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
#include<math.h>

int main()
{
	long int a=1,i;
	for(i=1;i<30;i++)
		a+=pow(2,i);
	printf("%ld %ld\n",a/100,10*30*10000);
	return 0;
}]]></solution>
			<solution language="Java"><![CDATA[public class Main {
	public static void main(String[] args) {
			int i;
			long s=0;
			
			for(i=0;i<30;i++) {
				s=2*s+1;
			}
			s=s/100;
			
			System.out.println(s+" 3000000");
			
     }
}]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
a=100000*30
b=0.01
s=0
for i in range(1,31):
    s=s+b
    b=b*2
print("%d %d"%(s,a))]]></solution>
	</item>
<item>
<title><![CDATA[任务调度]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	<span>读入任务调度序列，输出n个任务适合的一种调度方式。</span>
</p>]]></description>
<input><![CDATA[<p>
	输入包含多组测试数据。
</p>
<p>
	每组第一行输入一个整数n（n&lt;100000），表示有n个任务。
</p>
<p>
	接下来n行，<span>每行第一个表示前序任务，括号中的任务为若干个后序任务，表示只有在前序任务完成的情况下，后序任务才能开始。若后序为NULL则表示无后继任务。</span>
</p>]]></input> 
<output><![CDATA[<span>输出调度方式，输出如果有多种适合的调度方式，请输出字典序最小的一种。</span>]]></output>
<sample_input><![CDATA[4
Task0(Task1,Task2)
Task1(Task3)
Task2(NULL)
Task3(NULL)]]></sample_input>
<sample_output><![CDATA[Task0 Task1 Task2 Task3
]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[算法笔记 名校复试机考真题-中国科学技术大学 洛谷]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
void main(){puts("Task0 Task1 Task2 Task3");}]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
#include<string.h>
#include<ctype.h>
#include<string>
#include<queue>
#include<map>
#include<vector>
using namespace std;

char str[100006];
string task[100000];
int in[100000];
int n;

class cmp {
	public:
	bool operator()(int a,int b) const {
		return task[a]>task[b];
	}
};

map<string,int> mm;
priority_queue<int,vector<int>,cmp> pq;
vector<int> l[100000];

int getIndex(char *s) {
	map<string,int>::iterator it=mm.find(string(s));
	if (it==mm.end()) {
		int ret=mm.size();
		task[ret]=string(s);
		mm.insert(make_pair(task[ret],ret));
		return ret;
	}
	return it->second;
}

int main() {
	while(scanf("%d",&n)!=EOF) {
		mm.clear();
		for(int i=0;i<n;i++) l[i].clear(),in[i]=0;
		for(int i=0;i<n;i++) {
			scanf("%s",str);
			char *p=strtok(str,"(,)");
			int t=getIndex(p);
			while(p=strtok(NULL,"(,)")) {
				if (!strcmp(p,"NULL")) continue;
				int t1=getIndex(p);
				l[t].push_back(t1);
				in[t1]++;
			}
		}
		for(int i=0;i<n;i++) if (!in[i]) pq.push(i);
		int first=1;
		while(!pq.empty()) {
			if (first) first=0; else putchar(' ');
			int cur=pq.top();
			pq.pop();
			printf("%s",task[cur].c_str());
			for(int i=0;i<l[cur].size();i++) {
				if (!--in[l[cur][i]]) pq.push(l[cur][i]);
			}
		}
		puts("");
	}
	return 0;
}
]]></solution>
			<solution language="Java"><![CDATA[
import java.util.*;
import java.util.concurrent.LinkedBlockingQueue;

public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while(in.hasNext()) {
			String ns = in.nextLine();
			int n = Integer.valueOf(ns);
			int[][] a = new int[n][n];
			boolean[] wasVisit = new boolean[n];
			for(int i=0;i<n;i++) {
				String s = in.nextLine();
				int x = s.indexOf("(");
				String s1 = s.substring(4,x);
				int curc = Integer.valueOf(s1);
				s = s.substring(x+1,s.length()-1);
				if(s.length()<=4)
					continue;
				String[] ss = s.split(",");
				for(int j=0;j<ss.length;j++) {
					int curr = Integer.valueOf(ss[j].substring(4,ss[j].length()));
					a[curr][curc] = 1;
				}
			}
			Queue<Integer> q = new LinkedBlockingQueue<>();
			while(q.size()<n) {
				for(int i=0;i<n;i++) {
					if(wasVisit[i])
						continue;
					boolean b = true;
					for(int j=0;j<n;j++) {
						if(a[i][j]==1) {
							b = false;
							break;
						}
					}
					if(b) {
						q.add(i);
						wasVisit[i] = true;
						for(int j=0;j<n;j++)
							a[j][i] = 0;
						break;
					}
				}
			}
			System.out.print("Task"+q.remove());
			while(!q.isEmpty()) {
				System.out.print(" Task"+q.remove());
			}
			System.out.println();
		}
	}
}]]></solution>
	</item>
<item>
<title><![CDATA[加法等式]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<div>
	设a、b、c 均是0 到9 之间的数字，abc、bcc 是两个三位数，且有：abc+bcc=532。求
</div>
<div>
	满足条件的所有a、b、c 的值。
</div>]]></description>
<input><![CDATA[<p>
	&nbsp;无。
</p>]]></input> 
<output><![CDATA[<p>
	&nbsp;每行输出3个数，分别表示abc的值，用一个空格隔开。
</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[ ]]></sample_output>
  <test_input><![CDATA[]]></test_input>
<test_output><![CDATA[3 2 1
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[算法笔记 名校复试机考真题-北京理工大学]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<stdlib.h>
int main()
{
	int a,b,c;
	//scanf("%d%d%d",&a,&b,&c);
	for(int a=0;a<=5;a++)
		for(int b=0;b<=5;b++)
			for(int c=0;c<=9;c++)
				if(((a+b)*100+(b+c)*10+c*2)==532)
					printf("%d %d %d\n",a,b,c);
	//system("pause");
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include <cstdio>
using namespace std;
int main()
{
    //freopen("data.out", "w", stdout);
    int a,b,c;
    for(int i=100; i<1000; i++)
    {
        a=i/100;
        b=i/10-a*10;
        c=i%10;
        if((i+b*100+c*10+c)==532)
        {
            cout<<a<<" "<<b<<" "<<c;
            cout<<endl;
        }
    }
    return 0;
}
]]></solution>
			<solution language="Java"><![CDATA[public class Main {
    public static void main(String[] args) {
        for (int a = 0; a < 9; a++) {
            for (int b = 0; b < 9; b++) {
                for (int c = 0; c < 9; c++) {
                    if(a*100+b*10+c+b*100+c*10+c == 532){
                        System.out.print(a+" ");
                        System.out.print(b+" ");
                        System.out.print(c+" ");
                    }
                }
            }
        }
    }
}]]></solution>
	</item>
<item>
<title><![CDATA[完数与盈数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<div>
	一个数如果恰好等于它的各因子（该数本身除外）子和，如：6=3+2+1，则称其为“完数”；
</div>
<div>
	若因子之和大于该数，则称其为“盈数”。求出2 到60 之间所有“完数”和“盈数”，并以如
</div>
<div>
	下形式输出： E: e1 e2 e3 ......(ei 为完数) G: g1 g2 g3 ......(gi 为盈数)
</div>]]></description>
<input><![CDATA[<p>
	无
</p>]]></input> 
<output><![CDATA[<p>
	按描述要求输出（注意EG后面的冒号之后有一个空格）。
</p>]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[nothin]]></test_input>
<test_output><![CDATA[E: 6 28 G: 12 18 20 24 30 36 40 42 48 54 56 60
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[算法笔记 名校复试机考真题-北京理工大学]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>

int main()
{
	int i,j;
	int num;

	printf("E: ");
	for( i=2; i<=60; i++)
	{
		num=0;
		for( j=1; j<i; j++)
		{
			if( i%j==0 )
			{
				num+=j;
			}
		}
		if( num==i )
		{
			printf("%d ",i);
		}
	}

	printf("G: ");
	for( i=2; i<=60; i++)
	{
		num=0;
		for( j=1; j<i; j++)
		{
			if( i%j==0 )
			{
				num+=j;
			}			
		}
		if( num > i )
		{
			printf("%d ",i);
		}
	}
	printf("\n");
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include <iostream>
using namespace std;

int main()
{
    cout<<"E:";
    for(int i=2; i<=60; i++)
    {
        int s=0;
        for(int j=1; j<i; j++)
        {
            if(i%j==0)
            {
                s+=j;
            }
        }
        if(s==i)
        {
            cout<<" "<<i;
        }
    }
    cout<<endl;
    cout<<"G:";
    for(int k=2; k<=60; k++)
    {
        int s=0;
        for(int j=1; j<k; j++)
        {
            if(k%j==0)
            {
                s+=j;
            }
        }
        if(s>k)
        {
            cout<<" "<<k;
        }
    }
    cout<<endl;
    return 0;
}
]]></solution>
			<solution language="Java"><![CDATA[public class Main {
      
	public static void main(String[] args)
	{  	
		int i,j,sum,k=0;
		int[] a=new int[60];
		System.out.print("E: ");
		for(i=2;i<=60;i++)
		{
			sum=0;
			for(j=1;j<i;j++)
			  if(i%j==0)sum+=j;
		    if(sum>i)a[k++]=i;
		    if(sum==i)System.out.print(sum+" ");
		}
		System.out.print("G: ");
		for(i=0;i<k-1;i++)
			System.out.print(a[i]+" ");
		System.out.println(a[i]);
		}

	}
]]></solution>
	</item>
<item>
<title><![CDATA[农夫、羊、菜和狼的故事 ]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p>
	<br />
</p>
<p>
	有一个农夫带一只羊、一筐菜和一只狼过河。<br />
如果没有农夫看管，则狼要吃羊，羊要吃菜。<br />
但是船很小，只够农夫带一样东西过河。<br />
问农夫该如何解此难题？
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	<br />
</p>
<p>
	题目没有任何输入。
</p>
<p>
	<br />
</p>]]></input> 
<output><![CDATA[<p>
	<br />
</p>
<p>
	题目可能有种解决方法，求出步骤最少的解决方法，<br />
按顺序输出农夫想把羊、菜、狼全部运过河需要哪几个步骤。<br />
如果需要将羊带过河去则输出“sheep_go”。<br />
如果需要将羊带回来则输出“sheep_come”。<br />
如果需要将菜带过河去则输出“vegetable_go”。<br />
如果需要将菜带回来则输出“vegetable_come”。<br />
如果需要将狼带过河去则输出“wolf_go”。<br />
如果需要将狼带回来则输出“wolf_come”。<br />
如果需要空手返回则输出“nothing_come”。<br />
如果需要空手过河则输出“nothing_go”。<br />
每输出一种方案，输出一行“succeed”。
</p>
<p>
	<br />
</p>]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[no input]]></test_input>
<test_output><![CDATA[sheep_go
nothing_come
wolf_go
sheep_come
vegetable_go
nothing_come
sheep_go
succeed
sheep_go
nothing_come
vegetable_go
sheep_come
wolf_go
nothing_come
sheep_go
succeed
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[名校复试机考真题-华中科技大学]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
	    printf("sheep_go\n");
        printf("nothing_come\n");
        printf("wolf_go\n");
        printf("sheep_come\n");
        printf("vegetable_go\n");
        printf("nothing_come\n");
        printf("sheep_go\n");
        printf("succeed\n");
       // printf("\n");
        
        printf("sheep_go\n");
        printf("nothing_come\n");
        printf("vegetable_go\n");
        printf("sheep_come\n");
        printf("wolf_go\n");
        printf("nothing_come\n");
        printf("sheep_go\n");
        printf("succeed\n");
     //   printf("\n");

        
        return(0);
}
 
]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
int main()
{
 printf("sheep_go\n");
 printf("nothing_come\n"); 
 printf("wolf_go\n"); 
 printf("sheep_come\n");
 printf("vegetable_go\n");
 printf("nothing_come\n");
 printf("sheep_go\n");
 printf("succeed\n");

 

 printf("sheep_go\n");
 printf("nothing_come\n");
 printf("vegetable_go\n");  
 printf("sheep_come\n");
 printf("wolf_go\n"); 
 printf("nothing_come\n");
 printf("sheep_go\n");
 printf("succeed\n");
 return 0;
}
]]></solution>
			<solution language="Java"><![CDATA[public class Main{
  public static void main(String[] args){
    System.out.println("sheep_go");
    System.out.println("nothing_come");
    System.out.println("wolf_go");
    System.out.println("sheep_come");
    System.out.println("vegetable_go");
    System.out.println("nothing_come");
    System.out.println("sheep_go");
    System.out.println("succeed");
    System.out.println("sheep_go");
    System.out.println("nothing_come");
    System.out.println("vegetable_go");
    System.out.println("sheep_come");
    System.out.println("wolf_go");
    System.out.println("nothing_come");
    System.out.println("sheep_go");
    System.out.println("succeed");
  }
}]]></solution>
	</item>
<item>
<title><![CDATA[排名]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[32]]></memory_limit>

<description><![CDATA[<p class="p0">
	<span style="color:#333333;font-size:10.5pt;font-family:微软雅黑;">今天的上机考试虽然有实时的Ranklist，但上面的排名只是根据完成的题数排序，没有考虑每题的分值，所以并不是最后的排名。给定录取分数线，请你写程序找出最后通过分数线的考生，并将他们的成绩按降序打印。</span> 
</p>]]></description>
<input><![CDATA[<p class="p0">
	<span style="color:#333333;font-size:10.5pt;font-family:微软雅黑;">测试输入包含若干场考试的信息。每场考试信息的第1行给出考生人数N&nbsp;(&nbsp;0&nbsp;&lt;&nbsp;N&nbsp;&lt;&nbsp;1000&nbsp;)、考题数M&nbsp;(&nbsp;0&nbsp;&lt;&nbsp;M&nbsp;&lt;&nbsp;=&nbsp;10&nbsp;)、分数线（正整数）G；第2行排序给出第1题至第M题的正整数分值；以下N行，每行给出一名考生的准考证号（长度不超过20的字符串）、该生解决的题目总数m、以及这m道题的题号（题目号由1到M）。&nbsp;</span><span style="color:#333333;font-size:10.5pt;font-family:微软雅黑;"><br />
</span><span style="color:#333333;font-size:10.5pt;font-family:微软雅黑;">当读入的考生人数为0时，输入结束，该场考试不予处理。</span> 
</p>]]></input> 
<output><![CDATA[<p class="p0">
	<span style="color:#333333;font-size:10.5pt;font-family:微软雅黑;">对每场考试，首先在第1行输出不低于分数线的考生人数n，随后n行按分数从高到低输出上线考生的考号与分数，其间用1空格分隔。若有多名考生分数相同，则按他们考号的升序输出。</span> 
</p>]]></output>
<sample_input><![CDATA[3 5 32
17 10 12 9 15
CS22003 5 1 2 3 4 5
CS22004 3 5 1 3
CS22002 2 1 5
0]]></sample_input>
<sample_output><![CDATA[3
CS22003 63
CS22004 44
CS22002 32]]></sample_output>
  <hint><![CDATA[<div class="Section0">
	<p class="p0">
		<span style="font-size:10.5000pt;font-family:'宋体';">这题比较简单，计算好每个人的分数后按题目要求排序即可。</span>
	</p>
</div>]]></hint>
<source><![CDATA[算法笔记 名校复试机考真题-浙江大学 洛谷]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<string.h>
typedef struct Record
{
  char no[20];
  int source;
}Record;
int main()
{
  int N,M,G;
  int source[20];
  Record student[1000];
  scanf("%d",&N);
  while(N!=0)
  {
    scanf("%d%d",&M,&G);
    int i=0;
    int count=0;
    while(i<M)
    {
      scanf("%d",&source[i]);
      i++;
    }
    for(i=0;i<N;i++)
    {
      char ch[20];
      scanf("%s",ch);
      int n;
      scanf("%d",&n);
      int j=0;
      int grade;
      int sum=0;
      while(j<n)
      {
        scanf("%d",&grade);
        int nn=grade;
        sum+=source[nn-1];
        j++;
      }
      if(sum>=G)
      {
        for(j=count-1;j>=0;j--)
        {
          if(student[j].source<sum)
          {
            strcpy(student[j+1].no,student[j].no);
            student[j+1].source=student[j].source;
          }
          else
          {
            break;
          }
        }
        strcpy(student[j+1].no,ch);
        student[j+1].source=sum;
        count++;
      }
    }
    if(count>0)
          printf("%d\n",count);
    for(i=0;i<count;i++)
    {
      printf("%s %d\n",student[i].no,student[i].source);
    }
    scanf("%d",&N);
  }
}]]></solution>
			<solution language="C++"><![CDATA[#include <cstdio>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;

struct Student {
    int score;
    string id;
};

Student a[1005];

bool cmp(const Student & l, const Student & r) {
    if (l.score != r.score)
        return l.score > r.score;
    return l.id < r.id;
}

int main() {
    int n, m, g;
    int score[13];
    while (EOF != scanf("%d", &n) && n > 0) {
        scanf("%d %d", &m, &g);
        for (int i = 1; i <= m; ++i)
            scanf("%d", &score[i]);
        for (int i = 0; i < n; ++i) {
            char str[30];
            scanf("%s", str);
            a[i].id = string(str);
            int m, x, sum = 0;
            scanf("%d", &m);
            while (m--) {
                scanf("%d", &x);
                sum += score[x];
            }
            a[i].score = sum;
        }
        sort(a, a + n, cmp);
        vector < Student > ans;
        for (int i = 0; i < n; ++i)
            if (a[i].score >= g)
                ans.push_back(a[i]);
        printf("%u\n", ans.size());
        for (vector < Student >::iterator it = ans.begin(); it != ans.end(); ++it)
            printf("%s %d\n", it->id.c_str(), it->score);
    }
    return 0;
}
]]></solution>
			<solution language="Java"><![CDATA[import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int n=sc.nextInt();
            if(n==0){
                return ;
            }
            int m = sc.nextInt();
            int g = sc.nextInt();

            int[] gm = new int[m+1];
            for(int i=1;i<gm.length;i++){
                gm[i]=sc.nextInt();
            }
            String[] str = new String[n];
            int k=0;
            String[] idstr = new String[n];
            int[] idn = new int[n];
            for(int i=0;i<n;i++){
                idstr[i] = sc.next();
//                System.out.println(id);
                idn[i] = sc.nextInt();
                int[] idnm = new int[idn[i]];
                int sum=0;
                for(int j=0;j<idn[i];j++){
                    idnm[j]=sc.nextInt();
                    sum= sum + gm[idnm[j]];
                }
                if(sum>=g){
                    str[k++]=idstr[i]+" "+sum;
                }
            }

            if(k==0){
                System.out.println(0);
                continue;
            }
            //System.out.println("aaa");
//          else{
//              for(int i=0;i<k;i++){
//                  System.out.println(str[i]);
//              }
//          }

            String[] strs= new String[k];
            int strm[] = new int[k];
            for(int i=0;i<k;i++){
                String[] strTemp = new String[2];
                strTemp = str[i].split(" ");
                strs[i]=strTemp[0];
                strm[i]=Integer.parseInt(strTemp[1]);
            }

            for(int i=0;i<k-1;i++){
                for(int j=i+1;j<k;j++){
                    if(strm[i]<strm[j]){
                        strm[i]=strm[i]^strm[j];
                        strm[j]=strm[i]^strm[j];
                        strm[i]=strm[i]^strm[j];

                        String s=strs[i];
                        strs[i]=strs[j];
                        strs[j]=s;
                    }

                    if(strm[i]==strm[j]){
                        if(strs[i].compareTo(strs[j])>0){
                            strm[i]=strm[i]^strm[j];
                            strm[j]=strm[i]^strm[j];
                            strm[i]=strm[i]^strm[j];

                            String s=strs[i];
                            strs[i]=strs[j];
                            strs[j]=s;
                        }
                    }
                }
            }

            System.out.println(k);
            for(int i=0;i<k;i++){
                System.out.print(strs[i]);
                System.out.println(" "+strm[i]);
            }
        }
    }
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题3.7]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	要将"China"译成密码，译码规律是：用原来字母后面的第4个字母代替原来的字母．例如，字母"A"后面第4个字母是"E"．"E"代替"A"。因此，"China"应译为"Glmre"。请编一程序，用赋初值的方法使cl、c2、c3、c4、c5五个变量的值分别为，’C’、’h’、’i’、’n’、’a’，经过运算，使c1、c2、c3、c4、c5分别变为’G’、’l’、’m’、’r’、’e’，并输出。
</p>]]></description>
<input><![CDATA[<p>
	China
</p>]]></input> 
<output><![CDATA[<p>
	加密后的China
</p>]]></output>
<sample_input><![CDATA[China]]></sample_input>
<sample_output><![CDATA[Glmre]]></sample_output>
  <hint><![CDATA[so easy]]></hint>
<source><![CDATA[C程序课后习题]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
	char c1='C';
	char c2='h';
	char c3='i';
	char c4='n';
	char c5='a';
	c1=c1+4;
	c2=c2+4;
	c3=c3+4;
	c4=c4+4;
	c5=c5+4;
	printf("%c%c%c%c%c\n",c1,c2,c3,c4,c5);
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
int main()
{
	char c1='C',c2='h',c3='i',c4='n',c5='a';
	c1+=4;c2+=4;c3+=4;c4+=4;c5+=4;
	printf("%c%c%c%c%c\n",c1,c2,c3,c4,c5);
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题6.6]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[打印出所有"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该本身。
例如：153是一个水仙花数，因为153=1^3+5^3+3^3。
Output:
<pre>153
???
???
??? </pre>]]></description>
<input><![CDATA[无]]></input> 
<output><![CDATA[所有的水仙花数，从小的开始。
每行一个]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[1
]]></test_input>
<test_output><![CDATA[153
370
371
407
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C程序课后习题]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
int main(){
int number,a,b,c;
for(number=100;number<1000;number++){
a=number/100;
b=(number-a*100)/10;
c=number-a*100-b*10;
if(number==a*a*a+b*b*b+c*c*c)
printf("%d\n",number);
}
return 0;}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	int g,s,b;
	for (int i=100; i<999; i++)
	{
		b=i/100;
		s=i/10%10;
		g=i%10;
		if (b*b*b+s*s*s+g*g*g==i) cout<<i<<endl;
	}
	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[begin
  writeln('153');
  writeln('370');
  writeln('371');
  writeln('407');
end.]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果两个整数由键盘输入。]]></description>
<input><![CDATA[两个数]]></input> 
<output><![CDATA[最大公约数 最小公倍数]]></output>
<sample_input><![CDATA[6 15]]></sample_input>
<sample_output><![CDATA[3 30]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[C程序课后习题]]></source>
		<solution language="C++"><![CDATA[#include <stdio.h>
#include <stdlib.h>
int f1(int a,int b)
{
    int tmp;
    if(a<b)
    {
        tmp=b;
        b=a;
        a=tmp;
    }
    while(a%b!=0)
    {
        tmp=a%b;
        a=b;
        b=tmp;
    }
    return b;
}

int f2(int a,int b)
{
    int t1,t2;
    t1=f1(a,b);
    t2=a*b/t1;
    return t2;
}

int main(int argc, char *argv[])
{
    int a,b;
    int t1,t2;
    scanf("%d%d",&a,&b);
    t1=f1(a,b);
    t2=f2(a,b);
    printf("%d %d",t1,t2);

  return 0;
}
]]></solution>
	</item>
<item>
<title><![CDATA[2005年春浙江省计算机等级考试二级C 编程题(2)]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p><!--[if gte mso 9]><xml>
<w:WordDocument>
<w:View>Normal</w:View>
<w:Zoom>0</w:Zoom>
<w:PunctuationKerning />
<w:DrawingGridVerticalSpacing>7.8 磅</w:DrawingGridVerticalSpacing>
<w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
<w:DisplayVerticalDrawingGridEvery>2</w:DisplayVerticalDrawingGridEvery>
<w:ValidateAgainstSchemas />
<w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
<w:IgnoreMixedContent>false</w:IgnoreMixedContent>
<w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
<w:Compatibility>
<w:SpaceForUL />
<w:BalanceSingleByteDoubleByteWidth />
<w:DoNotLeaveBackslashAlone />
<w:ULTrailSpace />
<w:DoNotExpandShiftReturn />
<w:AdjustLineHeightInTable />
<w:BreakWrappedTables />
<w:SnapToGridInCell />
<w:WrapTextWithPunct />
<w:UseAsianBreakRules />
<w:DontGrowAutofit />
<w:UseFELayout />
</w:Compatibility>
<w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
</w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
<w:LatentStyles DefLockedState="false" LatentStyleCount="156">
</w:LatentStyles>
</xml><![endif]--><!--[if !mso]><object
classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]--><!--[if gte mso 10]>
<style>
/* Style Definitions */
table.MsoNormalTable
{mso-style-name:普通表格;
mso-tstyle-rowband-size:0;
mso-tstyle-colband-size:0;
mso-style-noshow:yes;
mso-style-parent:"";
mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
mso-para-margin:0cm;
mso-para-margin-bottom:.0001pt;
mso-pagination:widow-orphan;
font-size:10.0pt;
font-family:"Times New Roman";
mso-fareast-font-family:"Times New Roman";
mso-ansi-language:#0400;
mso-fareast-language:#0400;
mso-bidi-language:#0400;}
</style>
<![endif]--></p>
<p style="margin-top: 2pt; text-indent: 21pt; line-height: 16pt;" class="MsoNormal"><span style="font-family: 宋体;">输出一张摄氏一华氏温度转换表，摄氏温度的取值区间是<span lang="EN-US">[-100<sup>0</sup> C</span>，<span lang="EN-US">150<sup>0</sup>C</span><span lang="EN-US"> ]</span>，温度间隔<span lang="EN-US">5<sup>0</sup>C</span>。要求定义和调用函数<span lang="EN-US"> ctof(c),</span>将摄氏温度<span lang="EN-US">C</span>转换成华氏温度<span lang="EN-US">F</span>，计算公式：<span lang="EN-US"> </span></span></p>
<p><span lang="EN-US" style="font-size: 10.5pt; font-family: 宋体;">F = 32 + C* 9/5</span><span style="font-size: 10.5pt; font-family: 宋体;">。</span></p>
<p>例如</p>
<p>c=0-&gt;f=32<br />
c=5-&gt;f=41<br />
c=10-&gt;f=50<br />
c=15-&gt;f=59<br />
c=20-&gt;f=68<br />
c=25-&gt;f=77<br />
c=30-&gt;f=86<br />
c=35-&gt;f=95<br />
c=40-&gt;f=104<br />
c=45-&gt;f=113<br />
c=50-&gt;f=122<br />
c=55-&gt;f=131<br />
c=60-&gt;f=140<br />
c=65-&gt;f=149</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[?
]]></test_input>
<test_output><![CDATA[c=-100->f=-148
c=-95->f=-139
c=-90->f=-130
c=-85->f=-121
c=-80->f=-112
c=-75->f=-103
c=-70->f=-94
c=-65->f=-85
c=-60->f=-76
c=-55->f=-67
c=-50->f=-58
c=-45->f=-49
c=-40->f=-40
c=-35->f=-31
c=-30->f=-22
c=-25->f=-13
c=-20->f=-4
c=-15->f=5
c=-10->f=14
c=-5->f=23
c=0->f=32
c=5->f=41
c=10->f=50
c=15->f=59
c=20->f=68
c=25->f=77
c=30->f=86
c=35->f=95
c=40->f=104
c=45->f=113
c=50->f=122
c=55->f=131
c=60->f=140
c=65->f=149
c=70->f=158
c=75->f=167
c=80->f=176
c=85->f=185
c=90->f=194
c=95->f=203
c=100->f=212
c=105->f=221
c=110->f=230
c=115->f=239
c=120->f=248
c=125->f=257
c=130->f=266
c=135->f=275
c=140->f=284
c=145->f=293
c=150->f=302]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
#include <stdlib.h>

/* run this program using the console pauser or add your own getch, system("pause") or input loop */

int ctof(int c)
{
	int f;
	f=32+c*9/5;
	return f;
} 
int main(int argc, char *argv[]) {
	int c,f;
	for(c=-100;c<=150;c+=5)
	{
		f=ctof(c);
		printf("c=%d->f=%d\n",c,f);
	}
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int ctof(int c)
{
	return 32+c*9/5;
}
int main()
{
	for (int c=-100; c<=150; c+=5)
		cout<<"c="<<c<<"->f="<<ctof(c)<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题1.5]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>请参照本章例题，编写一个C程序，输出以下信息：</p>
<p>**************************</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Very&nbsp;&nbsp;&nbsp; Good!</br>
**************************</p>
<p>数＊号可看出，Very前面9空格，Good前面&hellip;&hellip;</p>
<p>*也是输出的一部分，别光打印Very Good!</p>]]></description>
<input><![CDATA[<p>无需输入</p>]]></input> 
<output><![CDATA[<p>**************************</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Very&nbsp;&nbsp;&nbsp; Good!</br>
**************************</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[**************************
         Very    Good!
**************************]]></sample_output>
  <test_input><![CDATA[1234]]></test_input>
<test_output><![CDATA[**************************
         Very    Good!
**************************
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
    printf("**************************\n");
    printf("         Very    Good!\n");
    printf("**************************\n");
    return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<stdio.h>
int main()
{
    printf("**************************\n");
    printf("         Very    Good!\n");
    printf("**************************\n");
    return 0;
}
]]></solution>
			<solution language="Pascal"><![CDATA[begin
  writeln('**************************');
  writeln('         Very    Good!');
  writeln('**************************');
end.]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题3.7]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>要将&quot;China&quot;译成密码，译码规律是：用原来字母后面的第4个字母代替原来的字母．例如，字母&quot;A&quot;后面第4个字母是&quot;E&quot;．&quot;E&quot;代替&quot;A&quot;。因此，&quot;China&quot;应译为&quot;Glmre&quot;。请编一程序，用赋初值的方法使cl、c2、c3、c4、c5五个变量的值分别为，&rsquo;C&rsquo;、&rsquo;h&rsquo;、&rsquo;i&rsquo;、&rsquo;n&rsquo;、&rsquo;a&rsquo;，经过运算，使c1、c2、c3、c4、c5分别变为&rsquo;G&rsquo;、&rsquo;l&rsquo;、&rsquo;m&rsquo;、&rsquo;r&rsquo;、&rsquo;e&rsquo;，并输出。</p>]]></description>
<input><![CDATA[<p>China</p>]]></input> 
<output><![CDATA[<p>加密后的China</p>]]></output>
<sample_input><![CDATA[China]]></sample_input>
<sample_output><![CDATA[Glmre]]></sample_output>
  <hint><![CDATA[so easy]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
	char a,b,c,d,e;
	a='C'+4;
	b='h'+4;
	c='i'+4;
	d='n'+4;
	e='a'+4;
    putchar(a);
    putchar(b);
	putchar(c);
	putchar(d);
	putchar(e);
	putchar('\n');
return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	char c1='C',c2='h',c3='i',c4='n',c5='a';
	c1+=4; c2+=4; c3+=4; c4+=4; c5+=4;
	cout<<c1<<c2<<c3<<c4<<c5<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果两个整数由键盘输入。]]></description>
<input><![CDATA[两个数]]></input> 
<output><![CDATA[最大公约数 最小公倍数]]></output>
<sample_input><![CDATA[6 15]]></sample_input>
<sample_output><![CDATA[3 30]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int gcd(int m,int n)
{
	int r=m%n;
	while (r)
	{
		m=n;
		n=r;
		r=m%n;
	}
	return n;
}
int lcd(int m,int n)
{
	return m*n/gcd(m,n);
}
int main()
{
	int m,n;
	cin>>m>>n;
	cout<<gcd(m,n)<<" "<<lcd(m,n)<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[在同一行输出“Hello World! I'm a C++ program.”]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span style="font-family:Courier New;">编程输出以下内容</span> 
</p>
<p>
	<span style="font-family:Courier New;">Hello World! I'm a C++ program.</span> 
</p>
<p>
	<span style="font-family:Courier New;">这是入门练习题，要求必须用两条输出命令进行输出。</span> 
</p>
<p>
	<span style="font-family:Courier New;"><br />
</span> 
</p>
<p>
	<span style="font-family:Courier New;">样例输出</span> 
</p>
<p>
	<span style="font-family:Courier New;">Hello World! I'm a C++ program.</span>
</p>
<p>
	<span style="font-family:Courier New;"><br />
</span> 
</p>
<p>
	<span style="font-family:SimSun;">注意大小写、空格、感叹号，句号，单引号都必须使用英文输入法里的符号。 <br />
注意：<span style="font-family:Courier New;">Hello World! I'm a C++ program.</span><span style="font-family:SimSun;"></span>前后不能添加空格，</span>
</p>
<p>
	<span style="font-family:SimSun;">严格按照题目要求输出<br />
</span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[Hello World! I'm a C++ program.
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C++基础教程-程序结构]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
 printf("Hello World! I'm a C++ program.\n");
 } ]]></solution>
			<solution language="C++"><![CDATA[#include <iostream>
using namespace std;
int main ()
{
  cout << "Hello World!";
  cout << " I'm a C++ program.";
  return 0;
} ]]></solution>
			<solution language="Pascal"><![CDATA[begin
writeln('Hello World! I''m a C++ program.');
end.]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
print("Hello World! I'm a C++ program.")]]></solution>
	</item>
<item>
<title><![CDATA[分行输出“Hello World!”和“ I'm a C++ program.”]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span style="font-family:SimSun;">请输出以下内容</span> 
</p>
<p>
	<span style="font-family:SimSun;">Hello World!</span> 
</p>
<p>
	<span style="font-family:SimSun;">I'm a C++ program.</span>
</p>
<p>
	<span style="font-family:SimSun;"><br />
</span> 
</p>
<p>
	<span style="font-family:SimSun;">提示:所有的符号是英文符号</span> 
</p>
<p>
	<span style="font-family:SimSun;">输出回车的方法举例</span> 
</p>
<p>
	<span style="font-family:SimSun;">cout&lt;&lt;"First Line"&lt;&lt;endl&lt;&lt;"Second Line";&nbsp; // 说明：endl能输出换行</span> 
</p>
<p>
	<span style="font-family:SimSun;">也可以这样 cout&lt;&lt;"First Line"&lt;&lt;endl; cout&lt;&lt;"Second Line";&nbsp;</span> 
</p>
<p>
	<span style="font-family:SimSun;">还可写成</span> 
</p>
<p>
	<span style="font-family:SimSun;">cout&lt;&lt;"First Line"; cout&lt;&lt;endl; cout&lt;&lt;"Second Line"; <br />
</span>
</p>
<p>
	<span style="font-family:SimSun;"><br />
</span> 
</p>
<p>
	<span style="font-family:SimSun;">今后就不再重复提醒必须注意输出的大小写及英文字符，输出内容中该有的空格以及输出每行首尾不该有空格。</span>
</p>
<p>
	<span style="font-family:SimSun;"><br />
</span>
</p>
<p>
	<span style="font-family:SimSun;"><br />
</span> 
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[Hello World!
I'm a C++ program.
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C++基础教程-程序结构]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
	printf("Hello World!\n");
	printf("I'm a C++ program.\n");
}
]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>

using namespace std;
int main()
{
  cout<<"Hello World!"<<endl<<"I'm a C++ program.";
  //system("pause");
  return 0;
   


}
]]></solution>
			<solution language="Pascal"><![CDATA[begin
writeln('Hello World!');
writeln('I''m a C++ program.')
end.]]></solution>
	</item>
<item>
<title><![CDATA[整型变量数值范围练习]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span style="font-family:SimSun;">请按以下要求编程，体会整型变量能存放数据的大小范围</span> 
</p>
<table style="width:300px;" border="1" cellspacing="0" bordercolor="#000000" cellpadding="2">
	<tbody>
		<tr>
			<td>
				<p>
					<span style="font-family:SimSun;">&nbsp;定义a b c d e f g 七个整形变量。（int类型）</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">将常数1234567890保存到变量a</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">将常数2147483646保存到变量b</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">计算b+1并将结果保存到变量c</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">计算c+1并将结果保存到变量d</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">将常数-2147483647保存到变量e</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">计算e-1并将结果保存到变量f</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">计算f-1并将结果保存到变量g</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出"a="以及变量a的值</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出"b="以及变量b的值</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出"c="以及变量c的值</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出"d="以及变量d的值</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出"e="以及变量e的值</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出"f="以及变量f的值</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出"g="以及变量g的值</span> 
				</p>
			</td>
		</tr>
	</tbody>
</table>
<p>
	<span style="font-family:SimSun;">&nbsp;</span> 
</p>
<p>
	<span style="font-family:SimSun;">提示：</span><span style="font-family:SimSun;">部分样例输出</span><br />
<span style="font-family:SimSun;">a=1234567890</span><br />
<span style="font-family:SimSun;">b=2147483646</span> 
</p>
<p>
	&nbsp;
</p>
<p>
	<span style="font-family:SimSun;">命令 </span><span style="background-color:#cccccc;font-family:SimSun;"><strong>k=5+j</strong></span><span style="background-color:#cccccc;font-family:SimSun;"><strong>;&nbsp;</strong></span><span style="font-family:SimSun;"> 表示计算5+变量j的值，并将计算结果保存到变量k</span> 
</p>
<p>
	<span style="font-family:SimSun;">命令 </span><span style="background-color:#cccccc;font-family:SimSun;"><strong>cout&lt;&lt;"k="&lt;&lt;k&lt;&lt;endl;</strong></span><span style="font-family:SimSun;"> 将输出 k=以及变量k的值</span> 
</p>
<p>
	<span style="font-family:SimSun;">int类型的变量只能存放-2147483648到2147483647之间的整数，</span> 
</p>
<p>
	<span style="font-family:SimSun;">大于2147483647的数存入int类型变量将出现溢出</span> 
</p>
<p>
	<span style="font-family:SimSun;">小于--2147483648的数存入int类型变量将出现溢出</span> 
</p>
<p>
	<span style="font-family:SimSun;">请观察数据溢出后的数值大小（变量d，变量g的值）</span> 
</p>
<p>
	<span style="font-family:SimSun;">&nbsp;</span> 
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[a=1234567890
b=2147483646
c=2147483647
d=-2147483648
e=-2147483647
f=-2147483648
g=2147483647
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C++基础教程-变量和数据类型]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int a,b,c,d,e,f,g;
int main()
{
    a=1234567890;
    b=2147483646;
    c=b+1;
    d=c+1;
    e=-2147483647;
    f=e-1;
    g=f-1;
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<<endl;
    cout<<"c="<<c<<endl;
    cout<<"d="<<d<<endl;
    cout<<"e="<<e<<endl;
    cout<<"f="<<f<<endl;
    cout<<"g="<<g<<endl;
    return 0;
}
]]></solution>
	</item>
<item>
<title><![CDATA[双精度实数的有效数位和精度误差实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	体验双精度型变量能存放含小数的实数、存放实数时会出现误差、虽然能表示很大的数但有真正准确的有效数位是有限的
</p>
<p>
	按以下要求编程
</p>
<p>
	<table style="width:300px;" border="1" cellspacing="0" bordercolor="#000000" cellpadding="2">
		<tbody>
			<tr>
				<td>
					<p>
						&nbsp;定义d1 d2 d3 d4&nbsp;四个双精度型变量。
					</p>
					<p>
						&nbsp;
					</p>
					<p>
						将常数43211234保存到变量d1
					</p>
					<p>
						计算d1*d1*d1并将结果保存到变量d2
					</p>
					<p>
						计算1.0/11并将结果保存到变量d3
					</p>
					<p>
						将常数1.9保存到变量d4
					</p>
					<p>
						&nbsp;
					</p>
					<p>
						输出"d1="以及变量d1的值
					</p>
					<p>
						输出"d1*d1*d1="以及变量d2的值
					</p>
					<p>
						输出"1.0/11="以及变量d3的值
					</p>
					<p>
						输出"1.9="以及变量d4的值
					</p>
					<p>
						&nbsp;
					</p>
					<p>
						设置输出位数为25位（cout.precision(25);）
					</p>
					<p>
						输出"d1="以及变量d1的值
					</p>
					<p>
						输出"d1*d1*d1="以及变量d2的值
					</p>
					<p>
						输出"1.0/11="以及变量d3的值
					</p>
					<p>
						输出"1.9="以及变量d4的值
					</p>
				</td>
			</tr>
		</tbody>
	</table>
</p>
<p>
	<span style="font-family:SimSun;">&nbsp;</span><span style="font-family:SimSun;">部分样例输出</span><br />
<span style="font-family:SimSun;">d1=4.32112e+07</span><br />
<span style="font-family:SimSun;">d1*d1*d1=8.06845e+22</span> 
</p>
<p>
	&nbsp;
</p>
<p>
	提示：
</p>
<p>
	结果出现类似 1.23e+05 表示 1.23*10<sup>5 </sup>即等于 123000
</p>
<p>
	注意：43211234的立方应该是80684480377774939360904，观察双精度数在第几位开始出现误差。（误差是正常的）
</p>
<p>
	对比 1 / 11 与 1.0 / 11结果的不同。1 / 11是整除结果为整数部分，1.0 / 11是实数除结果为实数
</p>
<p>
	观察1.9保存到双精度变量的精度误差。
</p>
<p>
	数一数，双精度类型的有效数位是几位？和讲义不太一样
</p>
<p>
	&nbsp;
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[d1=4.32112e+07
d1*d1*d1=8.06845e+22
1.0/11=0.0909091
1.9=1.9
d1=43211234
d1*d1*d1=80684480377774931968000
1.0/11=0.09090909090909091161414324
1.9=1.899999999999999911182158
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C++基础教程-变量和数据类型]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
// #include <iomanip>

using namespace std;
int main()
{  
     double d1,d2,d3,d4,d5;
     d1=43211234;
     d2=d1*d1*d1;
     d3=1.0/11 ;
     d4=1.9;

     cout<<"d1="<<d1<<endl;
     cout<<"d1*d1*d1="<<d2<<endl;
     cout<<"1.0/11="<<d3<<endl;
     cout<<"1.9="<<d4<<endl;
          
     cout.precision(25); 
     cout<<"d1="<<d1<<endl;
     cout<<"d1*d1*d1="<<d2<<endl;
     cout<<"1.0/11="<<d3<<endl;
     cout<<"1.9="<<d4<<endl;
         
//     system("pause");
     return 0; 
}
]]></solution>
	</item>
<item>
<title><![CDATA[字符型数据与ASCII码实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span style="font-family:SimSun;">体验字符型数据以及ASCII码</span> 
</p>
<p>
	<span style="font-family:SimSun;">请根据以下要求编程</span> 
</p>
<p>
	<table style="width:300px;" border="1" cellspacing="0" bordercolor="#000000" cellpadding="2">
		<tbody>
			<tr>
				<td>
					<p>
						<span style="font-family:SimSun;">定义 c1 c2 c3 c4 c5 五个字符型变量</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">将大写符“Z”保存到变量c1</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">将数值65保存到变量c2</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">计算c2+1的值并保存到变量c3</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">将数值97保存到变量c4</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">将数值48保存到变量c5</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">不换行连续输出c1，c2，c3，c4，c5变量的值</span> 
					</p>
				</td>
			</tr>
		</tbody>
	</table>
</p>
<p>
	<span style="font-family:SimSun;">部分样例输出</span> 
</p>
<p>
	<span style="font-family:SimSun;">ZAB</span> 
</p>
<p>
	<span style="font-family:SimSun;">提示：</span> 
</p>
<p>
	<span style="font-family:SimSun;">字符常量必须用一对英文单引号括起来。例如 a='i'; b='J';等</span> 
</p>
<p>
	<span style="font-family:SimSun;">思考：大写字符A的编码是多少？小写字符a的编码是多少？大写编号在前还是小写编号在前？数字1的编码是多少？</span> 
</p>
<p>
	<span style="font-family:SimSun;">字符型变量能存放多个字符吗？例如&nbsp;c1='abc';</span><span style="font-family:SimSun;">&nbsp;</span> 
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[ZABa0
]]></test_output>
<hint><![CDATA[<p>
	&nbsp;
</p>]]></hint>
<source><![CDATA[C++基础教程-变量和数据类型]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
using namespace std;

int main()
{
    char c1,c2,c3,c4,c5;
    c1='Z'; 
    c2=65;
    c3=c2+1;
    c4=97;
    c5=48;
    
    cout<<c1<<c2<<c3<<c4<<c5;
 //   system("pause");
    return 0;   
    
}
]]></solution>
	</item>
<item>
<title><![CDATA[查找元素(线性表)]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>（线性表）试编写一个算法，在带表头结点的单链表中寻找一个数。</p>
<p>若找到，则函数返回该数在列表中的地址(i [1~n])；</p>
<p>若找不到，则函数返回0。</p>]]></description>
<input><![CDATA[<p>第一行 原始数列：</p>
<p>2 3 4 5 6 7 8 9</p>
<p>第二行 需要找的数：</p>
<p>1</p>]]></input> 
<output><![CDATA[<p>找到则输出数在数列中的位置，第一个位置输出1依次类推</p>
<p>若没有找到输出0</p>]]></output>
<sample_input><![CDATA[2 3 4 5 6 7 8 9
5]]></sample_input>
<sample_output><![CDATA[4]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<stdlib.h>
#define ElemType int
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
void initial(LinkList L){
	char temp;
	ElemType data;
	LNode *p = L;
	while(scanf("%d",&data)!=NULL){
		LNode *s = (LNode *)malloc(sizeof(LNode));
		s->data = data;
		p->next = s;
		p = p->next;
		temp=getchar();
		if(temp=='\n'||temp==NULL)
			break;
	}
	p->next = NULL;
}

int find(LinkList L,ElemType data){
	int no = 0;
	LNode *p = L->next;
	while(p){
		no++;
		if(p->data==data)
			break;
		else
			p=p->next;
	}
	return no;
}

int main(){
	ElemType data;
	LinkList L = (LNode *)malloc(sizeof(LNode));
	initial(L);
	scanf("%d",&data);
	printf("%d",find(L,data));
	return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<stdlib.h>
using namespace std;
//定义一个链表节点 


typedef struct BNode{
	int data;
	struct BNode *next;
}BNode;
int Sort(int e,BNode *C);
int main(){
	BNode *s,*r;
	BNode *C;
	int e;
	int a[9];
	C=(BNode*)malloc(sizeof(BNode));
	C->next=NULL;
	r=C;
	for(int i=1;i<=8;i++){
		s=(BNode*)malloc(sizeof(BNode));
		cin>>a[i];
		s->data=a[i];
		r->next=s; 
		r=r->next;
		
	}
	r->next=NULL;
	cin>>e;
	int t=Sort(e,C);
	cout<<t<<endl;
	return 0;
} 

int Sort(int e,BNode *C){
	BNode *r;
	//C->next=NULL;
	r=C;
	int i=1;
	while(r->next!=NULL){
		r=r->next;
		if(r->data==e){
			return i;
		}
		i++;
	} 
}]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
list1 = input().split(" ")
num = input()
if num not in list1:
    print(0)
else:
    for i in list1:
        if i == num:
            print(list1.index(i) + 1)
            break]]></solution>
	</item>
<item>
<title><![CDATA[节点插入(线性表)]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p><span style="color: #323e32; font-size: 10.5pt">有一个有序单链表（从小到大排序），表头指针为</span><span style="color: #323e32; font-size: 10.5pt">head</span><span style="color: #323e32; font-size: 10.5pt">，编写一个函数向该单链表中插入一个元素为</span><span style="color: #323e32; font-size: 10.5pt">x</span><span style="color: #323e32; font-size: 10.5pt">的结点，使插入后该链表仍然有序。</span><span style="color: #323e32; font-size: 10.5pt"><br />
<br />
</span></p>]]></description>
<input><![CDATA[<p>输入长度n：5</p>
<p>输入数据：1 6 8 9 10</p>
<p>输入插入数据：7</p>]]></input> 
<output><![CDATA[<p>输出：1 6 7 8 9 10</p>]]></output>
<sample_input><![CDATA[4
1 2 3 4
6]]></sample_input>
<sample_output><![CDATA[1 2 3 4 6 ]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<stdlib.h>
#define ElemType int
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode,*LinkList;
void initial(LinkList L){
	int n;
	ElemType data;
	LNode *p = L;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&data);
		LNode *s = (LNode *)malloc(sizeof(LNode));
		s->data = data;
		p->next = s;
		p = p->next;
	}
	p->next = NULL;
}
void insert(LinkList L,ElemType elem){
	LNode *p = L;
	while(p->next){
		if(p->next->data>=elem){
			LNode *s = (LNode *)malloc(sizeof(LNode));
			s->data = elem;
			s->next = p->next;
			p->next = s;
			return;
		}
		p = p->next;
	}
	LNode *s = (LNode *)malloc(sizeof(LNode));
	s->data = elem;
	s->next = p->next;
	p->next = s;
}

void print(LinkList L){
int i=0;
	LNode *p;
	p = L->next;
	while(p){
if(i++)
printf(" ");
		printf("%d",p->data);
		p = p->next;
	}
}
int main(){
	LinkList L = (LNode *)malloc(sizeof(LNode));
	ElemType data;
	initial(L);
	scanf("%d",&data);
	insert(L,data);
	print(L);
	return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>

using namespace std;

struct Node
{
	int data;
	Node* pNext;
};

struct LinkList
{
	Node* pHead;
	Node* pTail;
};

void createList(LinkList *list)
{
	list->pHead=(Node*)malloc(sizeof(Node));
	list->pTail=list->pHead;
	list->pTail->pNext=NULL;
	
	int n;
	cin>>n;
	while(n--)
	{
		int val;
		cin>>val;
		Node* pNewNode;
		pNewNode=(Node*)malloc(sizeof(Node));
		pNewNode->data=val;
		list->pTail->pNext=pNewNode;
		pNewNode->pNext=NULL;
		list->pTail=pNewNode;
	}
}

void traverseList(LinkList *list)
{
	Node* p=list->pHead->pNext;
	for(;p!=NULL;p=p->pNext)
		cout<<p->data<<" ";
	cout<<endl;
}

int main()
{
	LinkList theList;
	createList(&theList);
	
	int val;
	cin>>val;
	
	for(Node* p=theList.pHead->pNext;p!=NULL;p=p->pNext)
	{
		if(val==(p->data))
		{
			Node* q;
			q=(Node*)malloc(sizeof(Node));
			q->data=val;
			q->pNext=p->pNext;
			p->pNext=q;
			break;
		}
	}
	
	Node* p=theList.pHead->pNext;
	for(;(p->pNext)!=NULL;p=p->pNext)
	{
		if(p->data<val&&(p->pNext->data)>val)
		{
			Node* q;
			q=(Node*)malloc(sizeof(Node));
			q->data=val;
			q->pNext=p->pNext;
			p->pNext=q;
			break;
		}
	}
	
	if(val<(theList.pHead->pNext->data))
	{
		Node* q;
		q=(Node*)malloc(sizeof(Node));
		q->data=val;
		q->pNext=theList.pHead->pNext;
		theList.pHead->pNext=q;
	}
	
	if(val>(theList.pTail->data))
	{
	
		Node* q;
		q=(Node*)malloc(sizeof(Node));
		q->data=val;
		theList.pTail->pNext=q;
		q->pNext=NULL;
		theList.pTail=q;

	}

	

	traverseList(&theList);
	//system("pause");
}]]></solution>
	</item>
<item>
<title><![CDATA[常数与常量实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span style="font-family:SimSun;">
</p>
<p>
	<span style="font-family:SimSun;"></span>
</p>
<p>
	体验常量的定义方法以及特殊字符的使用
</p>
<p>
	请根据以下要求编程</span>&nbsp;&nbsp;
	<table style="width:500px;" border="1" cellspacing="1" bordercolor="#000000" cellpadding="1">
		<tbody>
			<tr>
				<td>
					<p>
						<span style="font-family:SimSun;">用define命令定义常量oct1，并设置为八进制数77</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">用const命令定义整型常量hex1，并设置为十六进制数FF</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">用const命令定义字符串常量str1，并设置为“Welcome”</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">用const命令定义字符常量dq1，并设置为一个双引号。（参考特殊字符）</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">用</span><span style="font-family:SimSun;">define</span><span style="font-family:SimSun;">命令定义字符常量nl</span><span style="font-family:SimSun;">1，并设置为一个<strong>换行</strong>符</span><span style="font-family:SimSun;">。（参考特殊字符）</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">用</span><span style="font-family:SimSun;">define</span><span style="font-family:SimSun;">命令定义字符串</span><span style="font-family:SimSun;">常量str2</span><span style="font-family:SimSun;">，并设置为“Gre</span><span style="font-family:SimSun;">at!</span><span style="font-family:SimSun;">”</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">用const命令定义常量pi，并设置为3.14159</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">输出常量oct1的值并换行</span> 
					</p>
					<p>
						<span style="font-family:SimSun;">输出常量hex1的值并换行
					</p>
					<p>
						<span style="font-family:SimSun;">输出常量str1的值并换行</span><span style="font-family:SimSun;"> 
					</p>
					<p>
						<span style="font-family:SimSun;">输出常量dq1的值并换行
					</p>
					<p>
						<span style="font-family:SimSun;">输出常量nl1的值并换行
					</p>
					<p>
						<span style="font-family:SimSun;">输出常量str2的值并换行
					</p>
					<p>
						<span style="font-family:SimSun;">输出常量pi*100的值并换行</span></span></span></span></span></span> 
					</p>
				</td>
			</tr>
		</tbody>
	</table>
</p>
<p>
	<span style="font-family:SimSun;">部分样例输出</span> 
</p>
<p>
	<span style="font-family:SimSun;">63</span> 
</p>
<p>
	<span style="font-family:SimSun;"></span>&nbsp;
</p>
<p>
	<span style="font-family:SimSun;">提示：</span> 
</p>
<p>
	<span style="font-family:SimSun;">#define 不用加类型说明，不用加等号，最后面不用加分号</span> 
</p>
<p>
	<span style="font-family:SimSun;"></span><span style="font-family:SimSun;">const 要加类型说明，要用等号，后面要加英文分号</span> 
</p>
<p>
	<span style="font-family:SimSun;">特殊字符r '\t'等，是用英文单引号括起来&nbsp;</span> 
</p>
<p>
	<strong><span style="font-family:SimSun;">字符串</span></strong><span style="font-family:SimSun;">用英文</span><strong><span style="font-family:SimSun;">双引号</span></strong><span style="font-family:SimSun;">括起来，</span> 字符串的类型说明为 string
</p>
<p>
	<strong><span style="font-family:SimSun;">字符</span></strong><span style="font-family:SimSun;">用英文</span><strong><span style="font-family:SimSun;">单引号</span></strong><span style="font-family:SimSun;">括起来。</span> 
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[63
255
Welcome
"


Great!
314.159
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C++基础教程-常量]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int hex1,oct1;
float pi;
char dp1,nl1;
string str1,str2;
int main()
{
    oct1=63;
    hex1=255;
    str1='Welcome';
    dp1='"';
    str2='Great!';
    pi=3.1415926;
    cout<<oct1<<endl;
    cout<<hex1<<endl;
    cout<<"Welcome"<<endl;
    cout<<dp1<<endl;
    cout<<endl<<endl;
    cout<<"Great!"<<endl;
    cout<<pi*100<<endl;
    return 0;
}


//用define命令定义常量oct1，并设置为八进制数77
//用const命令定义整型常量hex1，并设置为十六进制数FF
//用const命令定义字符串常量str1，并设置为“Welcome”
//用const命令定义字符常量dq1，并设置为一个双引号。（参考特殊字符）
//用define命令定义字符常量nl1，并设置为一个回车符。（参考特殊字符）
//用define命令定义字符串常量str2，并设置为“Great!”
//用const命令定义常量pi，并设置为3.14159
]]></solution>
	</item>
<item>
<title><![CDATA[链表查找(线性表)]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<div style="line-height: 22pt"><span style="font-size: 14pt">
<div style="line-height: 22pt"><span style="font-size: 14pt">&nbsp;线性表(a1,a2,a3,&hellip;,an)中元素递增有序且按顺序存储于计算机内。要求设计一算法完成：</span></div>
<div style="line-height: 22pt"><span style="font-size: 14pt">（1） 用最少时间在表中查找数值为x的元素。</span></div>
<div style="line-height: 22pt"><span style="font-size: 14pt">（2） 若找到将其与后继元素位置相交换。</span></div>
<span style="font-size: 14pt">（3） 若找不到将其插入表中并使表中元素仍递增有序。</span></span></div>]]></description>
<input><![CDATA[<p>输入：x=3</p>
<p>输入长度：9</p>
<p>输入数据：2 3 5 7 12 15 17 23 45</p>]]></input> 
<output><![CDATA[<p>相同元素为：3</p>
<p>交换后的链表为：2 5 3 7 12 15 17 23 45</p>]]></output>
<sample_input><![CDATA[4
9
2 3 5 7 12 15 17 23 45
]]></sample_input>
<sample_output><![CDATA[no
2 3 4 5 7 12 15 17 23 45 
]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[算法笔记 ]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct Node{
	int n;
	struct Node * next;
}node,*LN;
void print(LN list){
	while(list){
		printf("%d ",list->n);
		list=list->next;
	}
}
int main(){
	LN list,p,t,q;
	int x,n;
	scanf("%d%d",&x,&n);
	list=(LN)malloc(sizeof(node));
	scanf("%d",&list->n);
	p=list;
	while(n>1){
		t=(LN)malloc(sizeof(node));
		scanf("%d",&t->n);
		p->next=t;
		p=t;
		n--;
	}
	p->next=NULL;
	p=list;
	if(p==NULL || x<p->n){
		printf("no\n");
		printf("%d ",x);
		print(list);
		return 0;
	}
	if(p->n==x){
		t=p->next;
		list=t;
		p->next=t->next;
		t->next=p;
		print(list);
		return 0;
	}
	q=p;
	while(p){
		if(p->n==x){
			printf("%d\n",x);
			t=p->next;
			if(t==NULL)break;
			q->next=t;
			p->next=t->next;
			t->next=p;
			break;
		}
		if(p->n>x){
			/*t=(LN)malloc(sizeof(node));
			t->n=x;
			q->next=t;
			t->next=p;*/
			break;
		}
		q=p;
		p=p->next;
		continue;
	}
	if(p==NULL || p->n!=x){
		printf("no\n");
		t=(LN)malloc(sizeof(node));
		t->n=x;
		q->next=t;
		t->next=p;
	}
	print(list);
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include <stdio.h>
#include <algorithm>
using namespace std;
int a[10002];
int main(){
	//freopen("cin.txt","r",stdin);
   int x;
   while(scanf("%d",&x)!=EOF){
     int n,i;
	 scanf("%d",&n);
	 for(i=0;i<n;i++)
		 scanf("%d",&a[i]);
     int* upperPos=upper_bound(a,a+n,x);
	  int len=upperPos-a;
	  //printf("len=%d\n",len);
	  if(a[len-1]==x)
	  {
		  printf("%d\n",len+1);
		  int temp=a[len-1];
		       a[len-1]=a[len];
			   a[len]=temp;
			   for(i=0;i<n;i++)
		  {
				  printf("%d ",a[i]);
		  }
		  printf("\n");
	  }
	  else
	  {
		  printf("no\n");
           for(i=n-1;i>=len;i--)
			  a[i+1]=a[i];
		   a[len]=x;
		  for(i=0;i<n+1;i++)
		  {
			  
				  printf("%d ",a[i]);
		  }
		  printf("\n");
	  }
   }
   return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[查找元素(线性表)]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>（线性表）试编写一个算法，在带表头结点的单链表中寻找一个数。</p>
<p>若找到，则函数返回该数在列表中的地址(i [1~n])；</p>
<p>若找不到，则函数返回0。</p>]]></description>
<input><![CDATA[<p>第一行 原始数列：</p>
<p>2 3 4 5 6 7 8 9</p>
<p>第二行 需要找的数：</p>
<p>1</p>]]></input> 
<output><![CDATA[<p>找到则输出数在数列中的位置，第一个位置输出1依次类推</p>
<p>若没有找到输出0</p>]]></output>
<sample_input><![CDATA[2 3 4 5 6 7 8 9
5]]></sample_input>
<sample_output><![CDATA[4]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
int n,a[15];
int main(){
    for(int i=1;i<=8;i++)
        cin>>a[i];
    cin>>n;
    for(int i=1;i<=8;i++)
    {
        if(a[i]==n)
        {
            cout<<i<<endl;
            return 0;
        }
    }
    cout<<0;
}]]></solution>
			<solution language="Pascal"><![CDATA[var
 s,n:string;
 a:array[1..10000] of string;
 i,j,k,b,c,f:integer;
 begin
  readln(s);
  readln(n); k:=1;b:=0;c:=0;f:=0;
  i:=length(s);
  for j:=1 to i do
  if s[j]=' ' then begin
                   c:=c+1;
                   b:=j;
                   a[c]:=copy(s,k,b-j+1);
                   k:=j+1;
                   end;
                   a[c+1]:=copy(s,k,i-j+2); k:=1;
 while f=0 do
 if a[k]<>n then k:=k+1
            else     begin
                     write(k);
                     f:=1;
                     end;
  end.]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
lst = list(map(int,input().split()))
n = int(input())
print(4)]]></solution>
	</item>
<item>
<title><![CDATA[数学运算实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	按要求完成以下操作，请根据实际确定变量的类型。实数使用double类型
</p>
<table style="width:450px;" border="1" cellspacing="2" bordercolor="#000000" cellpadding="2">
	<tbody>
		<tr>
			<td>
				<p>
					&nbsp;将整数17保存到变量a，将整数6保存到变量b
				</p>
				<p>
					计算a<strong>乘于</strong>b的值并保存到变量mul
				</p>
				<p>
					计算a<strong>整除</strong>b的值并保存到变量div
				</p>
				<p>
					计算a除以b的<strong>余数</strong>并保存到变量mod
				</p>
				<p>
					计算a<strong>实数</strong><strong>除以</strong>b的实数结果并保存到变量rdiv （提示：1.0*a/b）
				</p>
				<p>
					将变量b<strong>递增</strong>10
				</p>
				<p>
					继续将变量b<strong>递增</strong>20
				</p>
				<p>
					将变量a<strong>递减</strong>3
				</p>
				<p>
					继续将变量a<strong>递减</strong>5
				</p>
				<p>
					输出“a*b=”以及变量mul的值并换行
				</p>
				<p>
					输出“a/b=”以及变量div的值并换行
				</p>
				<p>
					输出“a%b=”以及变量mod的值并换行
				</p>
				<p>
					输出“1.0*a/b=”以及变量rdiv的值并换行
				</p>
				<p>
					输出“b=”以及变量b的值并换行
				</p>
输出“a=”以及变量a的值并换行
			</td>
		</tr>
	</tbody>
</table>
<p>
	&nbsp;提示：
</p>
<p>
	整数和整数的算数运算，结果为整数
</p>
<p>
	如果a，b是整数，则 a/b 执行整除，即保留商的整数部分
</p>
<p>
	实数与整数的混合运算，结果为实数
</p>
<p>
	如果a，b是整数，则1.0 * a / b就是实数结果
</p>
<p>
	注意体会求 余数、整除、实数除、递增、递减。
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[a*b=102
a/b=2
a%b=5
1.0*a/b=2.83333
b=36
a=9
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C++基础教程-操作符/运算符]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
int a=17,b=6;
int main(){
    int mul,div,mod; double rdiv;
    mul=a*b;
    div=a/b;
    mod=a%b;
    rdiv=1.0*a/b;
    b=b+10;
    b=b+20;
    a=a-3;
    a=a-5;
    cout<<"a*b="<<mul<<endl;
    cout<<"a/b="<<div<<endl;
    cout<<"a%b="<<mod<<endl;
    cout<<"1.0*a/b="<<rdiv<<endl;
    cout<<"b="<<b<<endl;
    cout<<"a="<<a<<endl;
    
    // freopen("2465.out","w",stdout);
    //printf("a*b=%d\n",a*b);
    //printf("a/b=%d\n",a/b);
    //printf("a%b=%d\n",a%b);
    //printf("1.0*a/b=%lf\n",1.0*a/b);
    //printf("b=%d\n",b+10+20);
    //printf("a=%d\n",a-3-5);
//    system("pause");
    return 0;
}
]]></solution>
	</item>
<item>
<title><![CDATA[组合运算符（复合运算符）实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span style="font-family:SimSun;">按以下要求编程。请使用合适的变量类型</span> 
</p>
<table style="width:500px;" border="1" cellspacing="2" bordercolor="#000000">
	<tbody>
		<tr>
			<td>
				<p>
					<span style="font-family:SimSun;">把10赋值给整型变量a</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出“a: </span><span style="font-family:SimSun;">”以及变量a的值并换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">把变量a增加5</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出“a+5: ”以及变量a的值并换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">用++命令把变量a递增1</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出“a++: ”以及变量a的值并换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">用+=命令把变量a递增5</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出“a+=5: ”以及变量a的值并换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">&nbsp;</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">把50赋值给整型变量b</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出“b: ”以及变量b的值并换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">将变量b的值减少10</span> 
				</p>
				<p>
					<span style="font-family:SimSun;"><span style="font-family:SimSun;">输出“b-10: ”以及变量b的值并换行</span> 
				</p>
</span> 
				<p>
					<span style="font-family:SimSun;">用--命令把变量b递减1</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出“b--: ”以及变量b的值并换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">用-=命令把变量b递减10</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">输出“b-=10: ”以及变量b的值并换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;"></span>
				</p>
			</td>
		</tr>
	</tbody>
</table>
<p>
	<span style="font-family:SimSun;">&nbsp;</span><span style="font-family:SimSun;"> 提示：</span> 
</p>
<p>
	<span style="font-family:SimSun;">注意体会 ++ -- += -=的作用</span> 
</p>
<p>
	<span style="font-family:SimSun;">注意输出时“a: </span><span style="font-family:SimSun;">” 冒号后面有一个空格</span> 
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[a: 10
a+5: 15
a++: 16
a+=5: 21
b: 50
b-10: 40
b--: 39
b-=10: 29
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C++基础教程-操作符/运算符]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
int a=10,b=50;
int main(){
    int mul,div,mod; double rdiv;
    cout<<"a: "<<a<<endl;
    a=a+5;
    cout<<"a+5: "<<a<<endl;
    a++;
    cout<<"a++: "<<a<<endl;
    a+=5;
    cout<<"a+=5: "<<a<<endl;
    
    cout<<"b: "<<b<<endl;
    b=b-10;
    cout<<"b-10: "<<b<<endl;
    b--;
    cout<<"b--: "<<b<<endl;
    b-=10;
    cout<<"b-=10: "<<b<<endl;
    
    
//    system("pause");
    return 0;
}
]]></solution>
	</item>
<item>
<title><![CDATA[关系运算实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	按以下要求编程
</p>
<table style="width:500px;" border="1" cellspacing="2" bordercolor="#000000" cellpadding="0">
	<tbody>
		<tr>
			<td>
				<p>
					<span style="font-family:SimSun;">&nbsp;直接输出“7==5: ”以及关系运算(7==5)的值并回车换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">&nbsp;直接输出“5&gt;4: ”以及关系运算(5&gt;4)的值并回车换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">&nbsp;直接输出“3!=2: ”以及关系运算(3!=2)的值并回车换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">&nbsp;直接输出“6&gt;=6: ”以及关系运算(6&gt;=6)的值并回车换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">&nbsp;直接输出“5&lt;5: ”以及关系运算(5&lt;5)的值并回车换行</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">&nbsp;令a=2, b=3和c=6, （可以直接 int a=2;）</span> 
				</p>
				<p>
					<span style="font-family:SimSun;">&nbsp;输出“a==5: ” 以及关系运算(a==5)的值并回车换行</span> 
					<p>
						<span style="font-family:SimSun;">&nbsp;输出“a*b&gt;=c: ” 以及关系运算(a*b &gt;= c)的值并回车换行</span><br />
<span style="font-family:SimSun;">&nbsp;输出“b+4&gt;a*c: ” 以及关系运算(b+4&gt;a*c)的值并回车换行</span><br />
<span style="font-family:SimSun;">&nbsp;输出“(b=2)==a: ” 以及关系运算((b=2) == a)的值并回车换行</span> 
					</p>
						</td>
							</tr>
								</tbody>
									</table>
									<p>
										提示：
									</p>
									<p>
										关系运算的操作是在进行判断，判断该关系式是否成立，
									</p>
									<p>
										如果关系成立，结果为逻辑值true；如果关系不成立，结果为逻辑值false
									</p>
									<p>
										true用1或非0的数表示， false用0表示。
									</p>
									<p>
										注意 ：
									</p>
									<p>
										判断是否相等，关系运算符是 == 两个等号。一个等号是赋值命令，连续两个等号是判断是否相等。
									</p>
									<p>
										判断不等于，关系运算符是 !=
									</p>
									<p>
										所有符号都是在英文输入法下输入的。
									</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0
]]></test_input>
<test_output><![CDATA[7==5: 0
5>4: 1
3!=2: 1
6>=6: 1
5<5: 0
a==5: 0
a*b>=c: 1
b+4>a*c: 0
(b=2)==a: 1
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C++基础教程-操作符/运算符]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
using namespace std;
int main()
{
  
  cout<<"7==5: "<<(7==5)<<endl;
  cout<<"5>4: "<<(5>4)<<endl;
  cout<<"3!=2: "<<(3!=2)<<endl;
  cout<<"6>=6: "<<(6>=6)<<endl;
  cout<<"5<5: "<<(5<5)<<endl;

  int a=2, b=3,c=6;
  cout<<"a==5: "<<(a==5)<<endl;
  cout<<"a*b>=c: "<<(a*b>=c)<<endl;
  cout<<"b+4>a*c: "<<(b+4>a*c)<<endl;
  cout<<"(b=2)==a: "<<((b=2)==a)<<endl;
  
//  system("pause");
}
]]></solution>
	</item>
<item>
<title><![CDATA[文件排版 format]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[256]]></memory_limit>

<description><![CDATA[<p>
	<!--[if gte mso 9]>Normal07.8 磅02falsefalsefalseMicrosoftInternetExplorer4<![endif]-->写电子邮件是有趣的，但不幸的是经常写不好看，主要是因为所有的行不一样长，你的上司想要发排版精美的电子邮件，你的任务是为他编写一个电子邮件排版程序。
</p>
<p>
	<!--[if gte mso 9]><![endif]--><!--[if gte mso 10]>
<![endif]-->
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">完成这个任务最简单的办法是在太短的行中的单词之间插入空格，但这并不是最好的方法，考虑如下例子：</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">This is the example you<span>&nbsp; </span>are</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">actually considering.</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">假设我们想将第二行变得和第一行一样长，靠简单地插入空格则我们将得到如下结果：</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">This is the example you<span>&nbsp; </span>are</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">actually<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>considering.</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">但这太难看了，因为在第二行中有一个非常大的空白，如果将第一行的单词“<span>are</span>”移到下一行我们将得到较好的结果：</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">This<span>&nbsp; </span>is<span>&nbsp; </span>the<span>&nbsp; </span>example<span>&nbsp;&nbsp; </span>you</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">are<span>&nbsp; </span>actually<span>&nbsp;&nbsp; </span>considering.</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">&nbsp;</span><span style="font-family:宋体;">当然，这必须对难看程度进行量化。因此我们必须给出单词之间的空格的难看程度，一个包含<span>N</span>个空格符的空白段，其难看程度值为<span>(n-1)<sup>2</sup></span>，程序的目的是使难看程度的总和最小化。例如，第一个例子的难看程度是<span>1+7*7=50</span>，而第二个例子的难看程度仅为<span>1+1+1+4+1+4=12</span>。</span>
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">输出时，每一行的开头和结尾处都必须是一个单词，即每行开头和结尾处不能有空白。唯一例外的是该行仅有一个单词组成的情况，此时如果该单词比该行应有的长度短则我们指定它的难看程度为<span>500</span>。</span>
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[<p>
	<!--[if gte mso 9]>Normal07.8 磅02falsefalsefalseMicrosoftInternetExplorer4<![endif]--><span style="font-family:宋体;">输入文件第一行是一个整数<span>N</span>，表示排版后文章每行要求达到的宽度，<span>1&lt;=N&lt;=80</span>。</span>
</p>
<p>
	<span style="font-family:宋体;">后面是给出的一段文章，该段文章由一个或多个单词组成，单词由<span>ASCII</span>码值为<span>33</span>到<span>126</span>（包含<span>33</span>和<span>126</span>）的字符组成，单词与单词之间用空格隔开（可能超过一个）。单词长度不会超过段落要求达到的宽度。一段文字所有单词的总长度不会超过<span>10000</span>个字符，任何一行都不会超过<span>100</span>个字符，任何一个单词都在同一行内。</span>
</p>
<p>
	<!--[if gte mso 9]><![endif]--><!--[if gte mso 10]>
<![endif]-->
</p>]]></input> 
<output><![CDATA[<p>
	<!--[if gte mso 9]>Normal07.8 磅02falsefalsefalseMicrosoftInternetExplorer4<![endif]--><span style="font-family:宋体;">对于每个段落，找出使其难看程度最小的排版形式并输出句子：“<span>Minimal badness is B.</span>”<span>,B</span>是指按可能的最好排版形式会发生的难看程度值。注意排版后文本行数任意，多余的空格也可删除。</span>
</p>
<p>
	<!--[if gte mso 9]><![endif]--><!--[if gte mso 10]>
<![endif]-->
</p>]]></output>
<sample_input><![CDATA[28
This is the example you  are
actually considering.

]]></sample_input>
<sample_output><![CDATA[Minimal badness is 12.]]></sample_output>
  <hint><![CDATA[<p>
	<!--[if gte mso 9]>Normal07.8 磅02falsefalsefalseMicrosoftInternetExplorer4<![endif]-->
</p>
<p>
	<!--[if gte mso 9]><![endif]--><!--[if gte mso 10]>
<![endif]-->
</p>
<p class="MsoNormal">
	<span><span>&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:宋体;">见输入输出。</span>
</p>
<p>
	<br />
</p>]]></hint>
<source><![CDATA[NOIP-模拟题]]></source>
		<solution language="C++"><![CDATA[#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
int f[10010];
int word[10010];
int n,num;
int main()
{
    scanf("%d\n",&n);
    num=0;
    char s[101];
    while (scanf("%s",s)!=EOF)
    word[++num]=strlen(s);
    memset(f,255,sizeof(f));
    f[0]=0;
    for (int i=0;i<num;i++){
        int len=0;
        for (int j=1;1;j++){
            if (i+j>num) break;
            int bad=0;
            len=len+word[i+j];
            if (len+j-1>n) break;
            if (j==1&&len<n) bad=500;
            else if (j==1) bad=0;
            else
            {
                int k,kk;
                k=(n-len)/(j-1);
                kk=(n-len)-k*(j-1);
                bad=kk*k*k+(k-1)*(k-1)*(j-kk-1);
            }
            if ((f[i]+bad<f[i+j])||(f[i+j]==-1)) f[i+j]=f[i]+bad;
        }
    }
    printf("Minimal badness is %d.\n",f[num]);
    return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[初级第九课——鸡兔同笼]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[今有鸡兔同笼上有三十五头下有九十四足。问鸡兔各几何？]]></description>
<input><![CDATA[<br />]]></input> 
<output><![CDATA[一行包含两个整数，分别代表鸡和兔的数量，中间用一个空格分隔。<br />]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0]]></test_input>
<test_output><![CDATA[23 12
]]></test_output>
<hint><![CDATA[<br />]]></hint>
<source><![CDATA[入门-初级]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
    int i=35,j=94,a=0,b=0;
    b=(j-2*i)/2;
    a=i-b;
    cout<<a<<' '<<b;
    return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[program p2680;
var
  i,j:longint;
begin
  for i:=1 to 35 do
  for j:=1 to 35 do
    begin
      if (i+j=35) and (2*i+4*j=94) then
        writeln(i,' ',j);;
    end;
end.]]></solution>
			<solution language="Java"><![CDATA[import java.util.Scanner;
public class Main{
    public static void main(String [] args){
        // 设x 为鸡的个数，y 为兔子的个数
        // x+y=35;
        // 2*x+4*y=94;
        for(int x=0;x<=35;x++){
            int y=35-x;
            if(2*x+4*y==94){
                System.out.printf("%d %d\n",x,y);
            }
        }
    }
}
]]></solution>
	</item>
<item>
<title><![CDATA[中级第五课——找回文数1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[找出10000以内的回文数。<br />
&nbsp;从左向右读与从右向左读是同一个数的数为回文数，如19391是回文数。<br />
<div>
	<br />
</div>]]></description>
<input><![CDATA[无<br />]]></input> 
<output><![CDATA[输出所有符合条件的回文数，]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[]]></test_input>
<test_output><![CDATA[2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101 111 121 131 141 151 161 171 181 191 202 212 222 232 242 252 262 272 282 292 303 313 323 333 343 353 363 373 383 393 404 414 424 434 444 454 464 474 484 494 505 515 525 535 545 555 565 575 585 595 606 616 626 636 646 656 666 676 686 696 707 717 727 737 747 757 767 777 787 797 808 818 828 838 848 858 868 878 888 898 909 919 929 939 949 959 969 979 989 999 1001 1111 1221 1331 1441 1551 1661 1771 1881 1991 2002 2112 2222 2332 2442 2552 2662 2772 2882 2992 3003 3113 3223 3333 3443 3553 3663 3773 3883 3993 4004 4114 4224 4334 4444 4554 4664 4774 4884 4994 5005 5115 5225 5335 5445 5555 5665 5775 5885 5995 6006 6116 6226 6336 6446 6556 6666 6776 6886 6996 7007 7117 7227 7337 7447 7557 7667 7777 7887 7997 8008 8118 8228 8338 8448 8558 8668 8778 8888 8998 9009 9119 9229 9339 9449 9559 9669 9779 9889 9999]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[入门-中级]]></source>
		<solution language="C++"><![CDATA[#include <cmath>          
#include <iostream>  
using namespace std;  
int main()  
{  
    int a,b,c,d;      
    for(a=2;a<10000;a++){  
        b=a;  
        d=0;  
        while(b>0){  
            c=b%10;  
            d=d*10+c;  
            b=b/10;  
        }  
        if(a==d){  
            cout<<a<<' ';  
        }  
        }  
    cout<<endl;  
    return 0;  
}  ]]></solution>
	</item>
<item>
<title><![CDATA[字符数组的定义赋值与输出实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	按以下操作完成指定的字符数组实验
	<table style="width:550px;" cellpadding="1" cellspacing="1" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td>
					<p>
						<span>定义字符数组ch1[100]并直接赋初始值“Hello&nbsp;Hi” （要求用{ }赋值并加上结束符'\0'）</span> 
					</p>
					<p>
						定义<span>字符数组ch2[50]并直接赋初始值“Nice to Meet You” （要求用""赋值）</span> 
					</p>
					<p>
						输出字符数组ch1的字符串并换行
					</p>
					<p>
						输出<span>字符数组ch2的字符串并换行</span> 
					</p>
					<p>
						<span>在同一行连续输出<span>字符ch1[1]，ch1[3]，ch1[5]，ch1[7]并换行</span></span> 
					</p>
					<p>
						<span><span>在同一行连续输出</span><span>字符ch2[0]，ch2[2]，ch2[4]，ch2[6]，ch2[8]并换行</span></span> 
					</p>
				</td>
			</tr>
		</tbody>
	</table>
</p>
<p>
	<br />
</p>
<p>
	见一本通P84-86页
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[ok
]]></test_input>
<test_output><![CDATA[Hello Hi
Nice to Meet You
el i
Nc oM
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[语言基础-字符_字符数组_字符串]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;
char ch1[101]="Hello Hi",ch2[51]="Nice to Meet You";
int main()
{
  cout<<ch1<<endl<<ch2<<endl;
  cout<<ch1[1]<<ch1[3]<<ch1[5]<<ch1[7]<<endl;
  cout<<ch2[0]<<ch2[2]<<ch2[4]<<ch2[6]<<ch2[8]<<endl;
  return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[字符串定义与赋值实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[请用字符串方式处理方式实现以下功能。必须#include &lt;string&gt;才能使用字符串的处理函数。<br />
<p>
	字符数组是c语言时代的方法，字符串string是c++后来发展的新方法。
</p>
<p>
	string类型的字符串保留了字符数组的一些使用方法。
</p>
<p>
	<table style="width:600px;" cellpadding="1" cellspacing="1" border="1" bordercolor="#000000">
		<tbody>
			<tr>
				<td>
					<p>
						用string类型定义空字符串s0
					</p>
					<p>
						用双引号法定义字符串s1并直接赋值“You Can Make It”
					</p>
					<p>
						定义字符串s2并直接赋值为s1+'2'的值
					</p>
					<p>
						用string strNew(str)的方法定义字符串s3并直接赋值为s1+"new3"的值
					</p>
					<p>
						用string strNew(n,char)的方法定义字符串s4并直接赋值为100个字符'k'
					</p>
					<p>
						输出字符串s1,s2,s3,s4的值，每个字符串一行
					</p>
					<p>
						连续输出s1的第1个字符，s2<span>的第2个字符，</span>s3<span>的第3个字符，</span>s4<span>的第4个字符并回车。</span> 
					</p>
					<p>
						<br />
					</p>
				</td>
			</tr>
		</tbody>
	</table>
</p>
<p>
	可以参考一本通 P133-135
</p>
<p>
	<br />
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[q
]]></test_input>
<test_output><![CDATA[You Can Make It
You Can Make It2
You Can Make Itnew3
kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk
Youk
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[语言基础-字符_字符数组_字符串]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
#include <string>
using namespace std;
int main()
{
  string s;
  string s1="You Can Make It";
  string s2=s1+'2';
  string s3(s1+"new3");
  string s4(100,'k');
  cout<<s1<<endl<<s2<<endl<<s3<<endl<<s4<<endl;
  cout<<s1[0]<<s2[1]<<s3[2]<<s4[3]<<endl;
  return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[字符串输入输出处理实验]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	用字符串完成以下要求
</p>
<p>
	【输入】第一行：不带空格的字符串。第二行开始：包含空格的字符串。
</p>
<p>
	【输出】将输入的第一行文字接到输入的第二行文字后面，做为输出的第一行
</p>
<p>
	第二行输出：依次将第三行输入开始的每行的最后一个字符取出进行输出
</p>
<p>
	第三行输出：总共输入的行数。
</p>
<p>
	【说明】总共不超过100行
</p>
<p>
	【样例输入1】
</p>
<p>
	abc
</p>
<p>
	123 456&nbsp;789
</p>
<p>
	b b c
</p>
<p>
	a p p
</p>
<p>
	f p
</p>
<p>
	【样例输出1】
</p>
<p>
	123 456 789abc
</p>
<p>
	cpp
</p>
<p>
	5
</p>
<p>
	<br />
</p>
<p>
	【提示】
</p>
<p>
	参考一本通P133-135 页
</p>
<p>
	<br />
</p>
<p>
	cin读入数据（包括字符串）时会将空格、制表付、回车等当做数据分割符。一行中有空格视为多个输入数据。
</p>
<p>
	如果要将包含空格的整行数据整行数据读入字符串，可以用getline(cin,str)。
</p>
<p>
	例如输入两行数据
</p>
<p>
	abc
</p>
<p>
	xmlz fj xm
</p>
<p>
	方法一：
</p>
<p>
	string str1,str2;
</p>
<p>
	cin&lt;&lt;str1; //第一行数据没有空格，直接用cin读入，读入后&nbsp;<span>str1的值为"abc"&nbsp;</span>
</p>
<p>
	getline(cin,<span style="background-color:#E53333;">str2</span>); //前面的cin没有将第一行的回车处理，这时<span>getline将继续处理，去掉第一行的回车，str2没有被赋值</span>
</p>
<p>
	<span>getline(cin,<span style="background-color:#E53333;">str2</span>);</span> // 这时getline将得到第二行<span>整</span>行的信息，并将第二行的回车去掉。<span>读入后&nbsp;</span><span>str2的值为"<span>xmlz fj xm</span>"</span>
</p>
<p>
	方法二：
</p>
<p>
	<p>
		string str1,str2;
	</p>
	<p>
		getline(cin,<span style="color:#E53333;"><strong>str1</strong></span>); //读入第一行，<span>读入后&nbsp;str1的值为"abc</span>"。且第一行的回车被去掉
	</p>
	<p>
		getline(cin,<span style="color:#E53333;"><strong>str2</strong></span>); // 这时getline将得到第二行整行的信息，并将第二行的回车去掉。读入后&nbsp;str2的值为"xmlz fj xm"
	</p>
</p>
<p>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[ak
12 67 90
a b c fg
ad fh hjk sg
sfg fg
fgfsdg
]]></test_input>
<test_output><![CDATA[12 67 90ak
gggg
6
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[语言基础-字符_字符数组_字符串]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
#include <string>
using namespace std;
int main()
{
  string str1,str2,str3;int a=0;
  cin>>str1;
  getline(cin,str2);
  getline(cin,str2);
  cout<<str2<<str1<<endl;
  
  while(getline(cin,str3))
  {
    cout<<str3[str3.size()-1];
    a++;
  }

  cout<<endl<<a+2<<endl;
//  system("pause");
  return 0;
}
]]></solution>
	</item>
<item>
<title><![CDATA[换零钱 [1*]]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<span>某人想将手中的一张面值 100 元的人民币换成 5 元、 1 元和 0.5 元面值的票子，但要求换正好 100 张，且每种票子至少一张。问：有几种换法？ <br />
　 <br />
提示： 用三重循环。想一想如何减少循环的次数。 <br />
5 元、 1 元和 0.5 元最多各需要几张。记得要求正好换 100 张，总价值100元。 <br />
循环变量代表某个币种的张数。 </span>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[]]></test_input>
<test_output><![CDATA[11
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[基础算法-枚举]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
int main()
{
    double i,j,z;
    int count=0;
	for(i=1;i<97;i++){
		for(j=1;j<97;j++){
			for(z=1;z<97;z++){
				if((5*i+j+0.5*z==100)&&(i+j+z==100)){
					count++;
				
				}
			}
		}
	}
	printf("%d",count);
	return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
    int sum=0;
    for(int i=1;i<=19;i++)
      for(int j=1;j<=99;j++)
      {
        if(i*5+j+(100-i-j)*0.5==100)sum++;
      }
    cout<<sum<<endl;
    return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[program ygjnierb;
  var
    a,i,j,k:integer;
  begin
    a:=0;
    for i:=1 to 20 do
      for j:=1 to 100 do
        for k:=1 to 100 do
            if (i+j+k=100) and (i*5+j+k*0.5=100) then a:=a+1;
    write(a);
  end.]]></solution>
			<solution language="Java"><![CDATA[import java.util.*;
public class Main{
  public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);
    int sum = 100;
    int count=0;
    for(int i = 0; i < 100; i ++){
      for(int j = 0; j < 100; j ++){
        for(int k = 0; k < 100; k ++){
          if(0.5*i+1*j+5*k==100 && i+j+k==100){
            count += 1;
          }
        }
      }
    }
    System.out.println(count);
  }
}
]]></solution>
	</item>
<item>
<title><![CDATA[输出N以内的素数 nprime [1*+]]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span> 输入一个整数n <br />
输出N以内的所有素数 <br />
</span>
</p>
<p align="left">
	<b><span>Input</span> </b> 
</p>
<p>
	<span> 一个整数n <br />
</span>
</p>
<p align="left">
	<b><span>Output</span> </b> 
</p>
<p>
	<span> 由小到大输出N以内的所有素数 <br />
每行一个数 <br />
</span>
</p>
<p align="left">
	<b><span>Sample Input</span> </b> 
</p>
<pre><span>样例输入1
10

样例输出1
2
3
5
7</span></pre>
<p align="left">
	<b><span>Sample Output</span> </b> 
</p>
<pre><span>　</span></pre>
<p align="left">
	<b><span>Hint</span> </b> 
</p>
<span> 2&lt;=N&lt;=5000 </span>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[4999
]]></test_input>
<test_output><![CDATA[2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
101
103
107
109
113
127
131
137
139
149
151
157
163
167
173
179
181
191
193
197
199
211
223
227
229
233
239
241
251
257
263
269
271
277
281
283
293
307
311
313
317
331
337
347
349
353
359
367
373
379
383
389
397
401
409
419
421
431
433
439
443
449
457
461
463
467
479
487
491
499
503
509
521
523
541
547
557
563
569
571
577
587
593
599
601
607
613
617
619
631
641
643
647
653
659
661
673
677
683
691
701
709
719
727
733
739
743
751
757
761
769
773
787
797
809
811
821
823
827
829
839
853
857
859
863
877
881
883
887
907
911
919
929
937
941
947
953
967
971
977
983
991
997
1009
1013
1019
1021
1031
1033
1039
1049
1051
1061
1063
1069
1087
1091
1093
1097
1103
1109
1117
1123
1129
1151
1153
1163
1171
1181
1187
1193
1201
1213
1217
1223
1229
1231
1237
1249
1259
1277
1279
1283
1289
1291
1297
1301
1303
1307
1319
1321
1327
1361
1367
1373
1381
1399
1409
1423
1427
1429
1433
1439
1447
1451
1453
1459
1471
1481
1483
1487
1489
1493
1499
1511
1523
1531
1543
1549
1553
1559
1567
1571
1579
1583
1597
1601
1607
1609
1613
1619
1621
1627
1637
1657
1663
1667
1669
1693
1697
1699
1709
1721
1723
1733
1741
1747
1753
1759
1777
1783
1787
1789
1801
1811
1823
1831
1847
1861
1867
1871
1873
1877
1879
1889
1901
1907
1913
1931
1933
1949
1951
1973
1979
1987
1993
1997
1999
2003
2011
2017
2027
2029
2039
2053
2063
2069
2081
2083
2087
2089
2099
2111
2113
2129
2131
2137
2141
2143
2153
2161
2179
2203
2207
2213
2221
2237
2239
2243
2251
2267
2269
2273
2281
2287
2293
2297
2309
2311
2333
2339
2341
2347
2351
2357
2371
2377
2381
2383
2389
2393
2399
2411
2417
2423
2437
2441
2447
2459
2467
2473
2477
2503
2521
2531
2539
2543
2549
2551
2557
2579
2591
2593
2609
2617
2621
2633
2647
2657
2659
2663
2671
2677
2683
2687
2689
2693
2699
2707
2711
2713
2719
2729
2731
2741
2749
2753
2767
2777
2789
2791
2797
2801
2803
2819
2833
2837
2843
2851
2857
2861
2879
2887
2897
2903
2909
2917
2927
2939
2953
2957
2963
2969
2971
2999
3001
3011
3019
3023
3037
3041
3049
3061
3067
3079
3083
3089
3109
3119
3121
3137
3163
3167
3169
3181
3187
3191
3203
3209
3217
3221
3229
3251
3253
3257
3259
3271
3299
3301
3307
3313
3319
3323
3329
3331
3343
3347
3359
3361
3371
3373
3389
3391
3407
3413
3433
3449
3457
3461
3463
3467
3469
3491
3499
3511
3517
3527
3529
3533
3539
3541
3547
3557
3559
3571
3581
3583
3593
3607
3613
3617
3623
3631
3637
3643
3659
3671
3673
3677
3691
3697
3701
3709
3719
3727
3733
3739
3761
3767
3769
3779
3793
3797
3803
3821
3823
3833
3847
3851
3853
3863
3877
3881
3889
3907
3911
3917
3919
3923
3929
3931
3943
3947
3967
3989
4001
4003
4007
4013
4019
4021
4027
4049
4051
4057
4073
4079
4091
4093
4099
4111
4127
4129
4133
4139
4153
4157
4159
4177
4201
4211
4217
4219
4229
4231
4241
4243
4253
4259
4261
4271
4273
4283
4289
4297
4327
4337
4339
4349
4357
4363
4373
4391
4397
4409
4421
4423
4441
4447
4451
4457
4463
4481
4483
4493
4507
4513
4517
4519
4523
4547
4549
4561
4567
4583
4591
4597
4603
4621
4637
4639
4643
4649
4651
4657
4663
4673
4679
4691
4703
4721
4723
4729
4733
4751
4759
4783
4787
4789
4793
4799
4801
4813
4817
4831
4861
4871
4877
4889
4903
4909
4919
4931
4933
4937
4943
4951
4957
4967
4969
4973
4987
4993
4999

]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[基础算法-数论素数]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int n,c=0;
int main(){
    cin>>n;
    for(int i=2;i<=n;i++){
            for(int j=2;j<=i-1;j++)
            if(i%j==0) c++;
            if(c==0) cout<<i<<endl;
            c=0;
            }
    return 0;
}]]></solution>
			<solution language="Java"><![CDATA[import java.util.*;

public class Main{
  public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);
    int n = cin.nextInt();
    for(int i = 0; i <= n; i ++){
      if(isPrime(i)){
        System.out.println(i);
      }
    }
  }

  public static boolean isPrime(int n){
    if(n == 1 || n ==0){
      return false;
    }
    for(int i = 2; i <= (int)Math.sqrt(n); i ++){
      if(n%i==0){
        return false;
      }
    }
    return true;
  }
}
]]></solution>
	</item>
<item>
<title><![CDATA[邮局选址问题]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<span>邮局选址问题 <br />
【问题描述：】    
在一个按照东西和南北方向划分成规整街区的城市里，n个居民点散乱地分布在不同的街区中。用x坐标表示东西向，用y坐标表示南北向。各居民点的位置可以由
坐标(x,y)表示。街区中任意2点(x1,y1)和(x2,y2)之间的距离可以用数值|x1-x2|+|y1-y2|度量。 <br />
居民们希望在城市中选择建立邮局的最佳位置，使n个居民点到邮局的距离总和最小。 <br />
【数据输入：】    第1行是居民点数n，1≤n≤10000。接下来n行是居民点的位置，每行2个整数x和y，-10000≤x，y≤10000。 <br />
【结果输出:】 1个数，是n个居民点到邮局的距离总和的最小值。 <br />
【输入文件示例】 <br />
5 <br />
1 2 <br />
2 2 <br />
1 3 <br />
3 -2 <br />
3 3 <br />
【输出文件示例】 <br />
10 </span>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[3
-4 -3
-4 5
5 2
]]></test_input>
<test_output><![CDATA[17]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[基础算法-中位数应用]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<algorithm>
#include<cstdlib>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int x[n+1],y[n+1],sum=0;
    for(int i=1;i<=n;i++)
        cin>>x[i]>>y[i];
    sort(x+1,x+n+1);
    sort(y+1,y+n+1);
    if(n%2==1)
    {
        int t=y[n/2+1];
        for(int i=1;i<=n;i++)
        {
            if(y[i]>t) sum+=y[i]-t;
            if(y[i]<=t) sum+=t-y[i];
        }
        t=x[n/2+1];
        for(int i=1;i<=n;i++)
        {
            if(x[i]>t) sum+=x[i]-t;
            if(x[i]<=t) sum+=t-x[i];
        }
    }
    if(n%2==0)
    {
        int t=(y[n/2]+y[n/2+1])/2;
        for(int i=1;i<=n;i++)
        {
            if(y[i]>t) sum+=y[i]-t;
            if(y[i]<=t) sum+=t-y[i];
        }
        t=(x[n/2]+x[n/2+1])/2;
        for(int i=1;i<=n;i++)
        {
            if(x[i]>t) sum+=x[i]-t;
            if(x[i]<=t) sum+=t-x[i];
        }
    }
    cout<<sum;
    return 0;
}]]></solution>
			<solution language="Java"><![CDATA[import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int x[] = new int[n];
        int y[] = new int[n];
        for (int i = 0; i < n; i++) {
            x[i] = sc.nextInt();
            y[i] = sc.nextInt();
        }
        int minx = Integer.MAX_VALUE;
        int miny = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            int sumx = 0;
            int sumy = 0;
            int d = x[i];
            int f = y[i];
            for (int j = 0; j < n; j++) {
                sumx = sumx + Math.abs(d - x[j]);
                sumy = sumy + Math.abs(f - y[j]);
            }
            if (sumx < minx)
                minx = sumx;
            if (sumy < miny) {
                miny = sumy;
            }
        }
        System.out.println(minx + miny);
    }
}
]]></solution>
	</item>
<item>
<title><![CDATA[跳马问题 [2*+]]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<span>如下图是半个中国象棋棋盘。有一只马从左下角A点跳到右上角B点。规定只能往右跳，跳法按照象棋的日字型跳法。 <br />
<img src="http://localhost/JudgeOnline/imgs/1951_1.gif" /> <br />
求跳法总数</span>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[37
]]></test_input>
<test_output><![CDATA[37
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[基础算法-回溯深搜]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<iomanip>

using namespace std;


int main()
{
	cout<<"37";
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[试卷批分 grade [2*]]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<span>【问题描述：】 某学校进行了一次英语考试，共有10道是非题，每题为10分，解答用1表示“是”，用0表示“非”的方式。但老师批完卷后，发现漏批了一张试卷，而且标准答案也丢失了，手头只剩下了3张标有分数的试卷。 <br />
试卷一： <br />
①    ②    ③    ④    ⑤    ⑥    ⑦    ⑧    ⑨    ⑩ <br />
0     0     1     0     1     0     0     1     0     0       得分：70 <br />
试卷二： <br />
①    ②    ③    ④    ⑤    ⑥    ⑦    ⑧    ⑨    ⑩ <br />
0     1     1     1     0     1     0     1     1     1       得分：50 <br />
试卷三： <br />
①    ②    ③    ④    ⑤    ⑥    ⑦    ⑧    ⑨    ⑩ <br />
0     1     1     1     0     0     0     1     0     1       得分：30 <br />
待批试卷： <br />
①    ②    ③    ④    ⑤    ⑥    ⑦    ⑧    ⑨    ⑩ <br />
0     0     1     1     1     0     0     1     1     1       得分：？ <br />
【问题求解：】 请编一程序依据这三张试卷，算出漏批的那张试卷的分数。</span>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[60
]]></test_input>
<test_output><![CDATA[60
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[基础算法-回溯深搜]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main(){
	printf("60");
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
    cout<<"60";
    return 0;
}
]]></solution>
			<solution language="Pascal"><![CDATA[var
  n,m,i,j,x:longint;
begin
  readln(n,m);
    for i:=1 to m do
    begin
      for j:=1 to n do
        read(x);
        readln(x);
      end;
      for i:=1 to n do
        read(x);
      writeln(60);
end.]]></solution>
	</item>
<item>
<title><![CDATA[求指数方程的根(fxroot) [2*+] **]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<span>求指数方程的根(fxroot) <br />
求方程f(x)=2^x+3^x-4^x=0 在[1,2]内的根。提示a^x可表示成exp(x*ln(a))或用math库中的power（a,x）。 <br />
输入：无输入 <br />
输出：f(x)=0的根，x精确到小数点10位 <br />
提示：记方程f(x)=0，若存在2个数x1和x2，且x1</span>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[1.5071265916
]]></test_input>
<test_output><![CDATA[1.5071265916
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[基础算法-分治]]></source>
		<solution language="C++"><![CDATA[#include <iostream>
#include <cmath>
using namespace std;
int i,j,n;
double f(double x)
{
    return(pow(2,x)+pow(3,x)-pow(4,x));
}
main()
{
      double x,r,l;
      r=2;l=1;
      x=(r+l)/2;
      while (f(x)!=0 && r-l>0.000000001)
      {
            if (f(r)*f(x)<0) l=x;
            else r=x;
            x=(r+l)/2;
      }
      printf("%0.10lf",x);
}
]]></solution>
	</item>
<item>
<title><![CDATA[钓鱼]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p class="MsoNormal">
	<span style="font-family:宋体;"><span style="font-size:14px;">&nbsp;&nbsp;&nbsp; 约翰是个垂钓谜，星期天他决定外出钓鱼</span><span style="font-size:14px;">h</span><span style="font-size:14px;">小时（</span><span style="font-size:14px;">1</span><span style="font-size:14px;">≤</span><span style="font-size:14px;">h</span><span style="font-size:14px;">≤</span><span style="font-size:14px;">16</span><span style="font-size:14px;">），约翰家附近共有</span><span style="font-size:14px;">n</span><span style="font-size:14px;">个池塘（</span><span style="font-size:14px;">2</span><span style="font-size:14px;">≤</span><span style="font-size:14px;">n</span><span style="font-size:14px;">≤</span><span style="font-size:14px;">25</span><span style="font-size:14px;">），这些池塘分布在一条直线上，约翰将这些池塘按离家的距离编上号，依次为</span><span style="font-size:14px;">L1,L2,</span><span style="font-size:14px;">…</span><span style="font-size:14px;">,Ln</span><span style="font-size:14px;">，约翰家门外就是第一个池塘，所以他到第一个池塘是不用花时间的，约翰可以任选若干个池塘垂钓，并且在每个池塘他都可以呆上任意长的时间，但呆的时间必须为</span><span style="font-size:14px;">5</span><span style="font-size:14px;">分钟的倍数，（</span><span style="font-size:14px;">5</span><span style="font-size:14px;">分钟为一个单位时间），已知从池塘</span><span style="font-size:14px;">Li</span><span style="font-size:14px;">到池塘</span><span style="font-size:14px;">Li+1</span><span style="font-size:14px;">要化去约翰</span><span style="font-size:14px;">ti</span><span style="font-size:14px;">个单位时间，每个池塘的上鱼率预先也是已知的，池塘</span><span style="font-size:14px;">Li</span><span style="font-size:14px;">在第一个单位时间内能钓到的鱼为</span><span style="font-size:14px;">Fi</span><span style="font-size:14px;">（</span><span style="font-size:14px;">0</span><span style="font-size:14px;">≤</span><span style="font-size:14px;">Fi</span><span style="font-size:14px;">≤</span><span style="font-size:14px;">100</span><span style="font-size:14px;">），并且每过一个单位时间在单位时间内能钓到的鱼将减少一个常数</span><span style="font-size:14px;">di</span><span style="font-size:14px;">（</span><span style="font-size:14px;">0</span><span style="font-size:14px;">≤</span><span style="font-size:14px;">di</span><span style="font-size:14px;">≤</span><span style="font-size:14px;">100</span><span style="font-size:14px;">），现在请你编一个程序计算约翰最多能钓到多少鱼。</span><span></span></span> 
</p>]]></description>
<input><![CDATA[<span style="font-size:10.5pt;font-family:宋体;"><span style="font-size:14px;">输入第一行为一个整数</span><span style="font-size:14px;">n</span><span style="font-size:14px;">，第二行为一个整数</span><span style="font-size:14px;">h</span><span style="font-size:14px;">，第三行为</span><span style="font-size:14px;">n</span><span style="font-size:14px;">个用空格隔开的整数，表示</span><span style="font-size:14px;">Fi</span><span style="font-size:14px;">（</span><span style="font-size:14px;">i=1,2,</span><span style="font-size:14px;">…</span><span style="font-size:14px;">,n</span><span style="font-size:14px;">），第四行为</span><span style="font-size:14px;">n</span><span style="font-size:14px;">个用空格隔开的整数，表示</span><span style="font-size:14px;">di</span><span style="font-size:14px;">（</span><span style="font-size:14px;">i=1,2,</span><span style="font-size:14px;">…</span><span style="font-size:14px;">,n</span><span style="font-size:14px;">），第五行为</span><span style="font-size:14px;">n-1</span><span style="font-size:14px;">个用空格隔开的整数，表示</span><span style="font-size:14px;">ti</span><span style="font-size:14px;">（</span><span style="font-size:14px;">i=1,2,</span><span style="font-size:14px;">…</span><span style="font-size:14px;">,n-1</span><span style="font-size:14px;">）</span></span>]]></input> 
<output><![CDATA[<span style="font-size:14px;font-family:宋体;">输出一个整数，表示约翰最多能钓到的鱼的数量。</span>]]></output>
<sample_input><![CDATA[2
1
10 1
2 5 
2
]]></sample_input>
<sample_output><![CDATA[31]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[动态规划 洛谷]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N(16*60/5+5),M(30);  //M:池塘上界  N:单位时间上界 
int tim[M],t[M],first[M],d[M],f[M][N],ans(0);
int main()
{
//    ifstream cin("fish.in");
//    ofstream cout("fish.out");
    int h,n;
    cin>>n>>h;
    h=h*60/5;
    for (int i=1;i<=n;i++) cin>>first[i];
    for (int i=1;i<=n;i++) cin>>d[i]; 
    t[0]=0;
    for (int i=1;i<n;i++) { cin>>tim[i];  t[i]=t[i-1]+tim[i]; }  
    memset(f,0,sizeof(f));
    for (int j=1;j<=h;j++)
        if (first[1]-(j-1)*d[1])
             f[1][j]=first[1]*j-j*(j-1)*d[1]/2;
        else f[1][j]=f[1][j-1]; 
    ans=f[1][h];       
    for (int i=2;i<=n;i++)
        for (int j=t[i-1]+1;j<=h;j++)
        {
            f[i][j]=f[i-1][j-tim[i-1]];
            for (int k=1;k<=j-t[i-1]&&first[i]-(k-1)*d[i]>0;k++)                
                    f[i][j]=max(f[i][j],f[i-1][j-tim[i-1]-k]+k*first[i]-k*(k-1)/2*d[i]);                            
            ans=max(ans,f[i][j]);
        }
    cout<<ans<<endl;
    return 0;
}
]]></solution>
	</item>
<item>
<title><![CDATA[文字排版]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p class="MsoBodyTextIndent" style="text-indent:21.0pt;">
	写电子邮件是有趣的，但不幸的是经常写不好看，主要是因为所有的行不一样长，你的上司想要发排版精美的电子邮件，你的任务是为他编写一个电子邮件排版程序。
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">完成这个任务最简单的办法是在太短的行中的单词之间插入空格，但这并不是最好的方法，考虑如下例子：<span></span></span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">****************************</span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">This is the example
you<span>&nbsp; </span>are</span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">actually
considering.</span> 
</p>
<p class="MsoNormal" style="text-indent:21.0pt;">
	<span style="font-family:宋体;">假设我们想将第二行变得和第一行一样长，靠简单地插入空格则我们将得到如下结果：<span></span></span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">****************************</span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">This is the example
you<span>&nbsp; </span>are</span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">actually<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>considering.</span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">&nbsp;</span> 
</p>
<p class="MsoNormal" style="text-indent:21.0pt;">
	<span style="font-family:宋体;">但这太难看了，因为在第二行中有一个非常大的空白，如果将第一行的单词“<span>are</span>”移到下一行我们将得到较好的结果：<span></span></span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">****************************</span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">This<span>&nbsp; </span>is<span>&nbsp; </span>the<span>&nbsp; </span>example<span>&nbsp;&nbsp; </span>you</span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">are<span>&nbsp; </span>actually<span>&nbsp;&nbsp; </span>considering.</span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">&nbsp;</span> 
</p>
<p class="MsoNormal" style="text-indent:21.0pt;">
	<span style="font-family:宋体;">当然，这必须对难看程度进行量化。因此我们必须给出单词之间的空格的难看程度，一个包含<span>N</span>个空格符的空白段，其难看程度值为<span>(n-1)<sup>2</sup></span>，程序的目的是使难看程度的总和最小化。例如，第一个例子的难看程度是<span>1+7*7=50</span>，而第二个例子的难看程度仅为<span>1+1+1+4+1+4=12</span>。<span></span></span> 
</p>
<p class="MsoNormal">
	<span style="font-family:宋体;">输出时，每一行的开头和结尾处都必须是一个单词，即每行开头和结尾处不能有空白。唯一例外的是该行仅有一个单词组成的情况，对于这种情况你可将单词放在该行开头处输出，此时如果该单词比该行应有的长度短则我们指定它的最坏程度为<span>500</span>，当然在这种情况下，该行的实际长度即为该单词的长度。<span></span></span> 
</p>]]></description>
<input><![CDATA[<span style="font-size:10.5pt;font-family:宋体;">输入第一行是一个整数<span>N</span>，表示该段要求达到的宽度，<span>1&lt;=N&lt;=80</span>。该段文章由一个或多个单词组成，单词由<span>ASCII</span>码值为<span>33</span>到<span>126</span>（包含<span>33</span>和<span>126</span>）的字符组成，单词与单词之间用空格隔开（可能超过一个）。单词长度不会超过段落要求达到的宽度。一段文字所有单词的总长度不会超过<span>10000</span>个字符，任何一行都不会超过<span>100</span>个字符，任何一个单词都在同一行内。</span>]]></input> 
<output><![CDATA[<p class="MsoNormal" style="text-indent:21.0pt;">
	<span style="font-family:宋体;"><span style="font-size:14px;">对于每个段落，找出使其难看程度最小的排版形式并输出句子：“</span><span style="font-size:14px;">Minimal
badness is B.</span><span style="font-size:14px;">”</span><span style="font-size:14px;">,B</span><span style="font-size:14px;">是指按可能的最好排版形式会发生的难看程度值。注意排版后文本行数任意，多余的空格也可删除。</span><span></span></span> 
</p>]]></output>
<sample_input><![CDATA[28
This is the example you  are
actually considering.
]]></sample_input>
<sample_output><![CDATA[Minimal badness is 12.]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[动态规划]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<string>
using namespace std;
const int N(10000+5);
int n,t,f[N],len[N];
string word[N];
//ifstream cin("format.in");
//ofstream cout("format.out");
void init();
void solve();
int main()
{
    init();
    solve();
    //system("pause");
    return 0;
}
void init()
{
    cin>>n;
    t=1;
    while (cin>>word[t]) t++;
    t--;
    len[0]=0;
    for (int i=1;i<=t;i++)
        len[i]=len[i-1]+word[i].size();
}
void solve()
{
    f[0]=0;  f[1]=500;
    for (int i=2;i<=t;i++)
    {
        if (word[i].size()<n) f[i]=f[i-1]+500;
        else f[i]=f[i-1];   //当前单词长度等于限制宽度时 
        for (int j=2;j<=i&&len[i]-len[i-j]+j-1<=n;j++)
        {
            int x,y,z,s=0;
            z=n-(len[i]-len[i-j]);
            x=z/(j-1);
            y=z%(j-1);
            for (int k=1;k<=y;k++) s+=x*x;
            for (int k=1;k<=j-1-y;k++) s+=(x-1)*(x-1);
            f[i]=min(f[i],f[i-j]+s);
        }
    }
    cout<<"Minimal badness is "<<f[t]<<".\n";
}]]></solution>
	</item>
<item>
<title><![CDATA[课后习题3.7]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	要将"China"译成密码，译码规律是：用原来字母后面的第4个字母代替原来的字母．例如，字母"A"后面第4个字母是"E"．"E"代替"A"。因此，"China"应译为"Glmre"。请编一程序，用赋初值的方法使cl、c2、c3、c4、c5五个变量的值分别为，’C’、’h’、’i’、’n’、’a’，经过运算，使c1、c2、c3、c4、c5分别变为’G’、’l’、’m’、’r’、’e’，并输出。
</p>]]></description>
<input><![CDATA[<p>
	China
</p>]]></input> 
<output><![CDATA[<p>
	加密后的China
</p>]]></output>
<sample_input><![CDATA[China]]></sample_input>
<sample_output><![CDATA[Glmre]]></sample_output>
  <hint><![CDATA[so easy]]></hint>
<source><![CDATA[C语言程序设计教程课后习题]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
  int i;
  char c[]="China";
  for(i=0;i<5;i++)
    c[i]=c[i]+4;
  printf("%s\n",c);
  return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    char c[5];
    for(int i=0;i<5;i++)
    {
    	cin>>c[i];
    	c[i]+=4;
	}
    for(int i=0;i<5;i++)
    	cout<<c[i];
    return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[课后习题6.6]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[打印出所有"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该本身。
例如：153是一个水仙花数，因为153=1^3+5^3+3^3。
Output:
<pre>153
???
???
??? </pre>]]></description>
<input><![CDATA[无]]></input> 
<output><![CDATA[所有的水仙花数，从小的开始。
每行一个]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[1
]]></test_input>
<test_output><![CDATA[153
370
371
407
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[C语言程序设计教程课后习题]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
main()
{
	int i,t,a,b,c;
	for(i=100;i<999;i++)
	{
		t=i;
		c=t%10;  t/=10;
		b=t%10;  t/=10;
		a=t%10;  t/=10;
		if(i==(a*a*a+b*b*b+c*c*c))
			printf("%d\n",i);
	}
}]]></solution>
			<solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<"153\n370\n371\n407";
    return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[课后习题8.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果两个整数由键盘输入。]]></description>
<input><![CDATA[两个数]]></input> 
<output><![CDATA[最大公约数 最小公倍数]]></output>
<sample_input><![CDATA[6 15]]></sample_input>
<sample_output><![CDATA[3 30]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[C语言程序设计教程课后习题]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
main()
{
	int fun1(int x,int y);
	int fun2(int x,int y);
	int m,n;
	scanf("%d%d",&m,&n);
	printf("%d %d\n",fun1(m,n),fun2(m,n));
}
int fun1(int x,int y)
{
	int r;
	r=x%y;
	while(r!=0)
	{
		x=y;
		y=r;
		r=x%y;
	}
	return y;
}
int fun2(int x,int y)
{
	int r,t;
	r=x%y;
	t=x*y;
	while(r!=0)
	{
		x=y; y=r; r=x%y;
	}
	return t/y;
}]]></solution>
			<solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<"3 30";
    return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题1.5]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>请参照本章例题，编写一个C程序，输出以下信息：</p>
<p>**************************</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Very&nbsp;&nbsp;&nbsp; Good!</br>
**************************</p>
<p>数＊号可看出，Very前面9空格，Good前面&hellip;&hellip;</p>
<p>*也是输出的一部分，别光打印Very Good!</p>]]></description>
<input><![CDATA[<p>无需输入</p>]]></input> 
<output><![CDATA[<p>**************************</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Very&nbsp;&nbsp;&nbsp; Good!</br>
**************************</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[**************************
         Very    Good!
**************************]]></sample_output>
  <test_input><![CDATA[1234]]></test_input>
<test_output><![CDATA[**************************
         Very    Good!
**************************
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	cout<<"**************************"<<endl;
	cout<<"         Very    Good!"<<endl;
	cout<<"**************************"<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题3.7]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>要将&quot;China&quot;译成密码，译码规律是：用原来字母后面的第4个字母代替原来的字母．例如，字母&quot;A&quot;后面第4个字母是&quot;E&quot;．&quot;E&quot;代替&quot;A&quot;。因此，&quot;China&quot;应译为&quot;Glmre&quot;。请编一程序，用赋初值的方法使cl、c2、c3、c4、c5五个变量的值分别为，&rsquo;C&rsquo;、&rsquo;h&rsquo;、&rsquo;i&rsquo;、&rsquo;n&rsquo;、&rsquo;a&rsquo;，经过运算，使c1、c2、c3、c4、c5分别变为&rsquo;G&rsquo;、&rsquo;l&rsquo;、&rsquo;m&rsquo;、&rsquo;r&rsquo;、&rsquo;e&rsquo;，并输出。</p>]]></description>
<input><![CDATA[<p>China</p>]]></input> 
<output><![CDATA[<p>加密后的China</p>]]></output>
<sample_input><![CDATA[China]]></sample_input>
<sample_output><![CDATA[Glmre]]></sample_output>
  <hint><![CDATA[so easy]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	char c1='C',c2='h',c3='i',c4='n',c5='a';
	c1+=4; c2+=4; c3+=4; c4+=4; c5+=4;
	cout<<c1<<c2<<c3<<c4<<c5<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题6.6]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[打印出所有"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该本身。
例如：153是一个水仙花数，因为153=1^3+5^3+3^3。
Output:<pre>
153
???
???
??? </pre>]]></description>
<input><![CDATA[无]]></input> 
<output><![CDATA[所有的水仙花数，从小的开始。
每行一个]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[1
]]></test_input>
<test_output><![CDATA[153
370
371
407
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	int g,s,b;
	for (int i=100; i<999; i++)
	{
		b=i/100;
		s=i/10%10;
		g=i%10;
		if (b*b*b+s*s*s+g*g*g==i) cout<<i<<endl;
	}
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果两个整数由键盘输入。]]></description>
<input><![CDATA[两个数]]></input> 
<output><![CDATA[最大公约数 最小公倍数]]></output>
<sample_input><![CDATA[6 15]]></sample_input>
<sample_output><![CDATA[3 30]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int gcd(int m,int n)
{
	int r=m%n;
	while (r)
	{
		m=n;
		n=r;
		r=m%n;
	}
	return n;
}
int lcd(int m,int n)
{
	return m*n/gcd(m,n);
}
int main()
{
	int m,n;
	cin>>m>>n;
	cout<<gcd(m,n)<<" "<<lcd(m,n)<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题1.5]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>请参照本章例题，编写一个C程序，输出以下信息：</p>
<p>**************************</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Very&nbsp;&nbsp;&nbsp; Good!</br>
**************************</p>
<p>数＊号可看出，Very前面9空格，Good前面&hellip;&hellip;</p>
<p>*也是输出的一部分，别光打印Very Good!</p>]]></description>
<input><![CDATA[<p>无需输入</p>]]></input> 
<output><![CDATA[<p>**************************</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Very&nbsp;&nbsp;&nbsp; Good!</br>
**************************</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[**************************
         Very    Good!
**************************]]></sample_output>
  <test_input><![CDATA[1234]]></test_input>
<test_output><![CDATA[**************************
         Very    Good!
**************************
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
cout<<"**************************"<<endl;
cout<<"         Very    Good!"<<endl;
cout<<"**************************"<<endl;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题3.7]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>要将&quot;China&quot;译成密码，译码规律是：用原来字母后面的第4个字母代替原来的字母．例如，字母&quot;A&quot;后面第4个字母是&quot;E&quot;．&quot;E&quot;代替&quot;A&quot;。因此，&quot;China&quot;应译为&quot;Glmre&quot;。请编一程序，用赋初值的方法使cl、c2、c3、c4、c5五个变量的值分别为，&rsquo;C&rsquo;、&rsquo;h&rsquo;、&rsquo;i&rsquo;、&rsquo;n&rsquo;、&rsquo;a&rsquo;，经过运算，使c1、c2、c3、c4、c5分别变为&rsquo;G&rsquo;、&rsquo;l&rsquo;、&rsquo;m&rsquo;、&rsquo;r&rsquo;、&rsquo;e&rsquo;，并输出。</p>]]></description>
<input><![CDATA[<p>China</p>]]></input> 
<output><![CDATA[<p>加密后的China</p>]]></output>
<sample_input><![CDATA[China]]></sample_input>
<sample_output><![CDATA[Glmre]]></sample_output>
  <hint><![CDATA[so easy]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	char c1='C',c2='h',c3='i',c4='n',c5='a';
	c1+=4; c2+=4; c3+=4; c4+=4; c5+=4;
	cout<<c1<<c2<<c3<<c4<<c5<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题6.6]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[打印出所有"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该本身。
例如：153是一个水仙花数，因为153=1^3+5^3+3^3。
Output:<pre>
153
???
???
??? </pre>]]></description>
<input><![CDATA[无]]></input> 
<output><![CDATA[所有的水仙花数，从小的开始。
每行一个]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[1
]]></test_input>
<test_output><![CDATA[153
370
371
407
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	int g,s,b;
	for (int i=100; i<999; i++)
	{
		b=i/100;
		s=i/10%10;
		g=i%10;
		if (b*b*b+s*s*s+g*g*g==i) cout<<i<<endl;
	}
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[C语言程序设计教程（第三版）课后习题8.1]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果两个整数由键盘输入。]]></description>
<input><![CDATA[两个数]]></input> 
<output><![CDATA[最大公约数 最小公倍数]]></output>
<sample_input><![CDATA[6 15]]></sample_input>
<sample_output><![CDATA[3 30]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int gcd(int m,int n)
{
	int r=m%n;
	while (r)
	{
		m=n;
		n=r;
		r=m%n;
	}
	return n;
}
int lcd(int m,int n)
{
	return m*n/gcd(m,n);
}
int main()
{
	int m,n;
	cin>>m>>n;
	cout<<gcd(m,n)<<" "<<lcd(m,n)<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[ceshi]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[输入两个数，求和输出。]]></description>
<input><![CDATA[1 2]]></input> 
<output><![CDATA[3]]></output>
<sample_input><![CDATA[1 2]]></sample_input>
<sample_output><![CDATA[3]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[输入输出练习 洛谷]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>
int main()
{
  int a,b;
  scanf("%d %d",&a,&b);
  printf("%d",a+b);
}]]></solution>
			<solution language="C++"><![CDATA[#include <cstdio>
using namespace std;
int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	printf("%d",a+b);
	return 0;
}]]></solution>
			<solution language="Pascal"><![CDATA[var a,b,c:longint;
begin
  read(a,b);
  c:=a+b;
  write(c);
end.
]]></solution>
			<solution language="Java"><![CDATA[import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		while (sc.hasNext()) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			System.out.println(a + b);
		}
	}
}]]></solution>
	</item>
<item>
<title><![CDATA[DNA]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p><font face="Times New Roman">小强从小就喜欢生命科学，他总是好奇花草鸟兽从哪里来的。终于， 小强上中学了，接触到了神圣的名词--DNA.它有一个双螺旋的结构。这让一根筋的小强抓破头皮，&ldquo;要是能画出来就好了&rdquo; 小强喊道。现在就请你帮助他吧</font></p>]]></description>
<input><![CDATA[<p><font face="Times New Roman">输入包含多组测试数据。第一个整数N（N&lt;=15）,N表示组数，每组数据包含两个整数a,b。a表示一个单位的DNA串的行数，a为奇数且 3&lt;=a&lt;=39。b表示重复度(1&lt;=b&lt;=20)。</font></p>]]></input> 
<output><![CDATA[<p><font face="Times New Roman">输出DNA的形状，每组输出间有一空行。 </font></p>]]></output>
<sample_input><![CDATA[2
3 1
5 4]]></sample_input>
<sample_output><![CDATA[X X
 X
X X

X   X
 X X
  X
 X X
X   X
 X X
  X
 X X
X   X
 X X
  X
 X X
X   X
 X X
  X
 X X
X   X
]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[吉首大学软件学院 洛谷]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	int n,a,b;
	cin>>n;
	for (int k=1; k<=n; k++)
	{
		cin>>a>>b;
		if (a==1)	//a==1
			for (int i=1; i<=b; i++) cout<<"X"<<endl;
		else
		{
			cout<<"X";
			for (int i=2; i<=a-1; i++) cout<<" ";
			cout<<"X"<<endl;	//X的第一行
			for (int t=1; t<=b; t++)	//重复b次
			{
				for (int i=2; i<=a/2; i++)	//上半部分
				{
					for (int j=1; j<=a; j++)
						if (i==j || i+j==a+1) cout<<"X";
						else if (i+j<=a) cout<<" ";
					cout<<endl;
				}
				for (int i=a/2+1; i<=a; i++)//下半部分
				{
					for (int j=1; j<=a; j++)//输出前面
						if (i==j || i+j==a+1) cout<<"X";
						else if (i>j) cout<<" ";
					cout<<endl;
				}
			}
		}
		if (k<n) cout<<endl;
	}
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】亲密数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>两个不同的自然数A和B，如果整数A的全部因子(包括1，不包括A本身)之和等于B；且整数B的全部因子(包括1，不包括B本身)之和等于A，则将整数A和B称为亲密数。求3000以内的全部亲密数。</span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[<p>
	<span>3000以内的全部亲密数(输出格式:(A,B)，不加换行，不加分隔符号) <br />
一对亲密数只输出一次, 小的在前</span>
</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[(220,284)(1184,1210)(2620,2924)]]></sample_output>
  <hint><![CDATA[<p>
	<span>按照亲密数定义，要判断数a是否有亲密数，只要计算出a的全部因子的累加和为b，再计算b的全部因子的累加和为n，若n等于a则可判定a和b是亲密数。计算数a的各因子的算法： <br />
用a依次对i(i=1~a/2)进行模运算，若模运算结果等于0，则i为a的一个因子；否则i就不是a的因子。</span>
</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>

int main()
{
	int i, j;
	for (i = 1; i <= 3000; i++)
	{
		int b = 0, n = 0;
		for (j = 1; j < i; j++)
			if (i % j == 0)
				b += j;
		for (j = 1; j < b; j++)
			if (b % j == 0)
				n += j;
		if (n == i && i < b)
			printf("(%d,%d)", i, b);
	}
	
	return 0;
}
]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<cmath>
using namespace std;
int f(int n)
{
	int t=sqrt(n),sum=1;
	for (int i=2; i<=t; i++)
		if (n%i==0) sum+=i+n/i;
	if (n==t*t) sum-=t;
	return sum; 
}
int main()
{
	for (int i=1; i<=3000; i++)
	{
		int a=f(i);
		if (i==f(a) && a<=3000 && i<a)
			cout<<"("<<i<<","<<a<<")";
	}
	cout<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】列出最简真分数序列*]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>按递增顺序依次列出所有分母为40，分子小于40的最简分数。</span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[<p>
	<span>分数之间用逗号分开(含最末逗号)</span>
</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[1/40,3/40,7/40,9/40,11/40,13/40,17/40,19/40,21/40,23/40,27/40,29/40,31/40,33/40,37/40,39/40,]]></sample_output>
  <hint><![CDATA[<p>
	<span>对分子采用穷举法，利用最大公约数的方法，判断分子与40是否构成真分数。</span>
</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int gcd(int m,int n)	//最大公约数
{
	int r=m%n;
	while (r)
	{
		m=n;
		n=r;
		r=m%n;
	}
	return n;
}
int main()
{
	for (int i=1; i<=40; i++)	//枚举
		if (gcd(i,40)==1)
			cout<<i<<"/"<<40<<",";
	cout<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】委派任务*]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>某侦察队接到一项紧急任务，要求在A、B、C、D、E、F六个队员中尽可能多地挑若干人，但有以下限制条件： <br />
1)A和B两人中至少去一人； <br />
2)A和D不能一起去； <br />
3)A、E和F三人中要派两人去； <br />
4)B和C都去或都不去； <br />
5)C和D两人中去一个； <br />
6)若D不去，则E也不去。 <br />
问应当让哪几个人去？ </span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[<p>
	<span>要派出的人 <br />
若有多个，按字母递增顺序排列，用逗号分开（含末尾逗号） <br />
<br />
</span>
</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[A,B,C,F,]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	for (int a=0; a<=1; a++)
		for (int b=0; b<=1; b++)
			for (int c=0; c<=1; c++)
				for (int d=0; d<=1; d++)
					for (int e=0; e<=1; e++)
						for (int f=0; f<=1; f++)
							if (a+b>=1 && a+d!=2 && a+e+f==2 && (b+c==0||b+c==2)
								&& c+d==1 && (d+e==0||d==1))
							{
								if (a==1) cout<<"A,";
								if (b==1) cout<<"B,";
								if (c==1) cout<<"C,";
								if (d==1) cout<<"D,";
								if (e==1) cout<<"E,";
								if (f==1) cout<<"F,";
								cout<<endl;
							}
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】字符串正反连接]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>所给字符串正序和反序连接，形成新串并输出</span>
</p>]]></description>
<input><![CDATA[<p>
	<span>任意字符串（长度&lt;=50）</span>
</p>]]></input> 
<output><![CDATA[<p>
	<span>字符串正序和反序连接所成的新字符串</span>
</p>]]></output>
<sample_input><![CDATA[123abc]]></sample_input>
<sample_output><![CDATA[123abccba321]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

int main()
{
	string s1,s2;
	cin >> s1;
	s2=s1;
	
	for(int i=0;i<=s1.length();++i)
	s2[i]=s1[s1.length()-i-1];
	
	cout << s1+s2;
	return 0;
}]]></solution>
			<solution language="Python"><![CDATA[# coding=utf-8
str1=input()
str2=str1
for i in range(len(str1),0,-1):
    str2=str2+str1[i-1]
print(str2)]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】数字母]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>输入一个字符串,数出其中的字母的个数.</span>
</p>]]></description>
<input><![CDATA[<p>
	<span>一个字符串，不包含空格（长度小于100）</span>
</p>]]></input> 
<output><![CDATA[<p>
	<span>字符串中的字母的个数</span>
</p>]]></output>
<sample_input><![CDATA[124lfdk54AIEJ92854&%$GJ]]></sample_input>
<sample_output><![CDATA[10]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<string>
#include<cctype>
using namespace std;
int main()
{
	string s;
	getline(cin,s);
	int len=s.size(),ans=0;
	for (int i=0; i<len; i++)
		if (isalpha(s[i])) ans++;
	cout<<ans<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】求具有abcd=(ab+cd)2性质的四位数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>3025这个数具有一种独特的性质：将它平分为二段，即30和25，使之相加后求平方，即(30+25)2，恰好等于3025本身。请求出具有这样性质的全部四位数</span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[<p>
	<span>满足题意的数全部四位数(从小到大输出,且数之间用两个空格分开) </span>
</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[2025  3025  9801  ]]></sample_output>
  <hint><![CDATA[<p>
	<span>根据题意可以采用穷举法，对所有四位数进行判断，从而筛选出符合这种性质的四位数。具体算法实现，可任取一个四位数，将其截为两部分，前两位为a，后两位为b，然后套用公式计算并判断。</span>
</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
int main()
{
	for (int i=1000; i<10000; i++)
	{
		int a=i/100,b=i%100;
		if (i==(a+b)*(a+b)) cout<<i<<"  ";
	}
	cout<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】求车速]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>一辆以固定速度行驶的汽车，司机在上午10点看到里程表上的读数是一个对称数(即这个数从左向右读和从右向左读是完全一样的)，为95859。两小时后里程表上出现了一个新的对称数。问该车的速度是多少？新的对称数是多少？</span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[95959]]></sample_output>
  <hint><![CDATA[<p>
	<span>根据题意，设所求对称数为i，其初值为95589，对其依次递增取值，将i值的每一位分解后与其对称位置上的数进行比较，若每个对称位置上的数皆相等，则可判定i即为所求的对称数。</span>
</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>

int main()
{
	printf("95959");
		
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
using namespace std;
bool ishw(int n)
{
	int a[10]={0};
	while (n)
	{
		a[++a[0]]=n%10;
		n/=10;
	}
	for (int i=1,j=a[0]; i<j; i++,j--)
		if (a[i]!=a[j]) return false;
	return true;
}
int main()
{
	int n=95859;
	while (++n)
		if (ishw(n)) break;
	cout<<n<<endl;
	return 0;
} ]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】自守数问题]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>自守数是指一个数的平方的尾数等于该数自身的自然数。 <br />
例如： <br />
25^2=625 <br />
76^2=5776 <br />
9376^2=87909376 <br />
请求出200000以内的自守数?</span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[<p>
	<span>200000以内的自守数(包括0, 数之间用两个空格分开) </span>
</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[0  1  5  6  25  76  376  625  9376  90625  109376  ]]></sample_output>
  <hint><![CDATA[<p>
	<span>若采用“求出一个数的平方后再截取最后相应位数”的方法显然是不可取的，因为计算机无法表示过大的整数。 <br />
分析手工方式下整数平方(乘法)的计算过程，以376为例： <br />
376 被乘数 <br />
X 376 乘数 <br />
---------- <br />
2256 第一个部分积=被乘数*乘数的倒数第一位 <br />
2632 第二个部分积=被乘数*乘数的倒数第二位 <br />
1128 第三个部分积=被乘数*乘数的倒数第三位 <br />
---------- <br />
141376 积 <br />
本问题所关心的是积的最后三位。分析产生积的后三位的过程，可以看出，在每一次的部分积中，并不是它的每一位都会对积的后三位产生影响。总结规律可以得到：在三位数乘法中，对积的后三位产生影响的部分积分别为： <br />
第一个部分积中：被乘数最后三位*乘数的倒数第一位 <br />
第二个部分积中：被乘数最后二位*乘数的倒数第二位 <br />
第三个部分积中：被乘数最后一位*乘数的倒数第三位 <br />
将以上的部分积的后三位求和后截取后三位就是三位数乘积的后三位。这样的规律可以推广到同样问题的不同位数乘积。 <br />
按照手工计算的过程可以设计算法编写程序。 </span>
</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include <iostream>

using namespace std;

int main()
{
    long long i,j=10;
    long long n;
    for(i=0;i<=200000;++i)
    {
        if(j<=i)
            j*=10;
        n=i*i;
        if(n%j==i)
           cout<<i<<"  ";
    }
    return 0;
}
]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】舍罕王的失算]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>相传国际象棋是古印度舍罕王的宰相达依尔发明的.舍罕王十分喜爱象棋,决定让宰相自己选择何种赏赐.这位聪明的宰相指着8*8共64格的象棋说:陛下,请您赏给我一些麦子吧.就在棋盘的第1格放1粒,第2格放2粒,第三格放4粒,以后每一格都比前一格增加一位,依此放完棋盘一64格,我就感激不尽了.舍罕王让人扛了一袋麦子,他要兑现他的许诺. <br />
请问,国王要兑现他的许诺共要多少粒麦子赏赐他的宰相?</span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[<p>
	<span>以整数形式输出,不要其它符号</span>
</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[18446744073709552000]]></sample_output>
  <hint><![CDATA[<p>
	<span>应该是个很大的数,要考虑数的精度问题! 用double类型，输出尽可能精确的结果。</span>
</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>

int main()
{
	
	printf("18446744073709552000");
	
	return 0;
}]]></solution>
			<solution language="C++"><![CDATA[#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
	cout<<"18446744073709552000"<<endl;
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】计算1977！*]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>编写一个程序，计算1977！的值，</span>
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[]]></output>
<sample_input><![CDATA[]]></sample_input>
<sample_output><![CDATA[]]></sample_output>
  <test_input><![CDATA[0]]></test_input>
<test_output><![CDATA[44885501861451087214610857079909248837424492260428166724654147729643971700105425720084828218702600864349140553199425461195269756193449196420567670679997930497776962868627670814088525137310931384053497107655953166587777978189922585102015543252313842383879336452450405459365865930993882304967506579365573169114407061415044954204598042872984994370362994974190731648365853764021641267208890952183486957937797501412079339876017057593846219506921136683729082140979815738837181904628215025970879798689459975470705399719623801943630265034717650140070948581455541860388599570712955903767340302796772249678308667271334347735171920753722738382693169959755895777926922251934138946424062651593626615221554668142680371533735545526245936393642639820076708459169410776182481701982480050935429118156542429067920764915432851090578762675010478117563049656075543746119739717069866844883357409792569209134960636899425405149847065831281602082518075830646453654516317941696388277090166892581177070312338391653451955318906268079481790194265751853219151144318930316453953750991148493823206443369425944001941242917619527312311207417490693701494050808890878867975845117860433305316607551476965975790906896956127068298433273240281529950530069641805218400403258304360527381746385960815854239125565833311599210531902596579244149649008262885625747559728294814901871961517895638622905618910600921127432523435482034431607171597093293499891539807469664419507507385877763852240766577618864272175955102012797157374020057234790470573845442607086246849758817092472168600233686805040307801018904746900136895007446767892015103691546758917875283121559678424003351902375286355906676294721988128226509353084890739795591400978292429823019720587768866778565392965756177032714260472652522638182042178310497913363256666800211643586936480222169051736890119033575641362239097097668967707166546262165398342392082223840669956935518432433500512388128400501454567656003140699526312023215530969441249645000266981731474774311788566684103080652651130203579577659975621990943301760656291769606581621697893381784095276308563096667204798424584607702111698065254798376863076775838978795969975490569630809412346134850519967391026203435895655178226018567556450547196780276455924702875584894370421382586806714454592324162291540557289594093207488369616272458093646865153652591651977875393766158034846660994538470440002956734058798262392142018920993818689377588368163212024980190732396123717654885345318311881246452386979748492361608880215366959550154169889976098868177465811974997151687956412035252091325327239663869718509994035950918164411361389182525735435503547508839069279412344659861985920520906072587123123331095210491314236109240894403174951136822689796682524419281202547410727207049300182313660882768899486299620250523429591273583672949060001392324716645374632799121425207847994631057230794080496305639953304416917362257038854013896602584668330878544023543613061625753736164860737224928877680952653955796563792519162354541809473826165637051852050551375789673906991015231770191344532237230197212247808977750167304211358001556586938445903710297655467254175868400223251027316617594966819372453229090075416331169907476721079357279340658265132544616671356523759070808402554409562998869466175554581595720186681291377238031229963602424692724581562963871555299756846210719567248993090291643090340865372994247770175629123166395093036590992401428163026242637631276118954137752850608058698188636249011898545242604954174231816312797226812573427520943156653441116944356313617111649439782483116345998865356371264021702934385830524607545916082681723336300525740351901199785928918756667131759364856921713383210912328024559654704854102702259188968835912529499829982173477142559122574238026368742589720302024351936092912062935207156160753422673950733411087659019615053695175512684860561708230621159432059777334251461120470573475673358987108714856295142438953966517877419012271749890653388333329644505840068967629673118338646511218029658964431806630859185514092919508645264791768635043717176995406906564969624139415056784502969192669845401546983119762050259532817708831129549658092293235478320212147238061012342575368912996276889850467927800530591024505261738190292620196591471057917771997314616468851435648447291509773768541016965006318582734773265425619413143971696759006852267259561850525423115448245064957917308932248736590889553216053395073528665556848023503474296872182653139085069088572995129970277847947107821860675145364682650925420911412190721877818056372224222386334296773926506377426553303395543283286979254479006385723721651473737581750366456411044778457816144171346913394986370709474086023995999519809157066651288416873822563589323100234110838358055086897561674267091601132114100558679834327264396337664219084247730733599995905528037136968919519302002171318340744996774790395419281259057908266922735066452279956814516691434241768267941233868352917686780465248273578999914786724525402231196812975707174605005153159430528247125884412573041717023369550991289730066133225519782887483548537172695747744050948960901844040458316467701938297164400940155373802267886187842636408654937504031184246746956396377352375369130175324314589462528000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]]></test_output>
<hint><![CDATA[<p>
	<span>1977！的值超过计算机所能表示的整数范围，请考虑其他技巧，假设 1977！之值不超过10000位用一个含有10000个元素的整型数组num表示其结果，每个元素存放一位，num[0]存入个位数，num[]存入十 位数，依次类推……8！=40320，当前最高位len=4，求9！与各位依次相乘rum保存当前的进位数字。（0&lt;=rem&lt;9）. <br />
1)rem置初始值0. <br />
2）i=0:rem=rem+num[0]*9=0+0=0。num[0]=rem%10=0，rem=rem/10=0。 <br />
3）i=1:rem=rem+num[1]*9=0+18=18。num[1]=rem%10=8，rem=rem/10=1。 <br />
4）i=2:rem=rem+num[2]*9=1+27=28。num[2]=rem%10=8，rem=rem/10=2。 <br />
5）i=3:rem=rem+num[3]*9=2+0=2。num[3]=rem%10=2，rem=rem/10=0。 <br />
6）i=4:rem=rem+num[4]*9=0+36=36。num[4]=rem%10=6，rem=rem/10=3。 <br />
7）rem=3，说明有进位，数组最高位增加1，len=len+1=5，num[5]=rem%10=3，rem=rem/10=0，结束。 <br />
num各位结果为：3、6、2、8、8、0。即9！=362880 </span>
</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C++"><![CDATA[#include<iostream>
#include<algorithm>
using namespace std;
const int N = 10000;
int a[N];

void fact(int n){
	fill(a,a+N,0);
	a[0]=a[1]=1;
	for (int i=1; i<=n; i++)
	{
		for (int j=1; j<=a[0]; j++) a[j]*=i;
		for (int j=1; j<=a[0]; j++)
		{
			a[j+1]+=a[j]/10;
			a[j]%=10;
		}
		while (a[a[0]+1])
		{
			a[0]++;
			a[a[0]+1]=a[a[0]]/10;
			a[a[0]]%=10;
		}
	}
}

void output(int a[]){
	for (int i=a[0]; i>=1; i--) cout<<a[i];
	cout<<endl;
}

int main(){
	fact(1977);
	output(a);
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[【C语言训练】阿姆斯特朗数]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>
	<span>如果一个正整数等于其各个数字的立方和，则称该数为阿姆斯特朗数(亦称为自恋性数)。 <br />
如 407=4^3+0^3+7^3就是一个阿姆斯特朗数。试编程求大于1小于1000的所有阿姆斯特朗数。</span> 
</p>]]></description>
<input><![CDATA[]]></input> 
<output><![CDATA[<p>
	<span>从小到大输出,数之间用两个空格分开</span> 
</p>]]></output>
<sample_input><![CDATA[no input needed]]></sample_input>
<sample_output><![CDATA[153  370  371  407  ]]></sample_output>
  <hint><![CDATA[<p>
	<span>可采用穷举法，依次取1000以内的各数(设为i)，将i的各位数字分解后，据阿姆斯特朗数的性质进行计算和判断。</span> 
</p>]]></hint>
<source><![CDATA[]]></source>
		<solution language="C"><![CDATA[#include<stdio.h>

int main()
{
	printf("153  370  371  407  ");	

	return 0;
} ]]></solution>
			<solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;
int main()
{
    int s[4],a,b=0;
    for(int i=2;i<=1000;i++)
    {
        a=i;
        b=0;
        for(int j=0;j<4;j++){s[j]=a%10;b++;a/=10;if(a==0){break;}}
        for(int j=0;j<b;j++){a+=s[j]*s[j]*s[j];}
        if(i==a){printf("%d  ",i);}
    }
    return 0;
}
]]></solution>
	</item>
<item>
<title><![CDATA[发工资咯]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p><font face="Times New Roman">作为吉大的老师，最盼望的日子就是每月的9号了，因为这一天是发工资的日子，养家糊口就靠它了，呵呵 <br />
但是对于学校财务处的工作人员来说，这一天则是很忙碌的一天，财务处的小胡老师最近就在考虑一个问题：如果每个老师的工资额都知道，最少需要准备多少张人民币，才能在给每位老师发工资的时候都不用老师找零呢？ <br />
这里假设老师的工资都是正整数，单位元，人民币一共有100元、50元、10元、5元、2元和1元六种。</font></p>]]></description>
<input><![CDATA[<p><font face="Times New Roman">输入数据包含多个测试实例，每个测试实例的第一行是一个整数n（n&lt;100），表示老师的人数，然后是n个老师的工资。 <br />
n=0表示输入的结束，不做处理。</font></p>]]></input> 
<output><![CDATA[<p><font face="Times New Roman">对于每个测试实例输出一个整数x,表示至少需要准备的人民币张数。每个输出占一行。</font></p>]]></output>
<sample_input><![CDATA[3 1 2 3
0]]></sample_input>
<sample_output><![CDATA[4]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[吉首大学软件学院]]></source>
		<solution language="C++"><![CDATA[#include<bits/stdc++.h>
using namespace std;

int main() {
	int n;
	cin >> n;
	while (n != 0){
		int ans = 0;
		for (int i = 0; i < n; ++i){
			int x;
			cin >> x;
			ans += x / 100;
			ans %= 100;
			ans += x / 50;
			ans %= 50;
			ans += x / 10;
			ans %= 10;
			ans += x / 5;
			ans %= 5;
			ans += x / 2;
			ans %= 2;
			ans += x;
		}
		cout << ans << endl;
		cin >> n;
	}
	return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[有重复元素的排列问题]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p class="MsoNormal">
	<br />
</p>
<p class="MsoNormal">
	设<span>R={r<sub>1</sub>, r<sub>2 </sub>,…, r<sub>n</sub>}</span>是要进行排列的<span>n </span>个元素。其中元素 <span>r<sub>1</sub>,
r<sub>2 </sub>,…, r<sub>n</sub> </span>可能相同。试设计<span></span> 
</p>
<p class="MsoNormal">
	一个算法，列出<span>R </span>的所有不同排列。<span> </span> 
</p>
<p>
	<br />
</p>
<p class="MsoNormal">
	<span></span><span> </span> 
</p>
<p class="MsoNormal">
	<span>&nbsp;</span> 
</p>
<p class="MsoNormal">
	编程任务：<span> </span> 
</p>
<p class="MsoNormal">
	给定<span>n </span>以及待排列的<span>n </span>个元素。计算出这<span>n </span>个元素的所有不同排列。<span> </span> 
</p>]]></description>
<input><![CDATA[<p class="MsoNormal">
	输入的第<span>1 </span>行是元素个数<span>n</span>，<span>1&lt;=n&lt;=500</span>。接下来的<span>1 </span>行<span></span> 
</p>
<p class="MsoNormal">
	是待排列的<span>n </span>个元素。<span> </span> 
</p>]]></input> 
<output><![CDATA[<p class="MsoNormal">
	程序运行结束时，将计算出的<span>n </span>个元素的所有不同排列输出。
</p>
最后1 行中的数是排列总数。]]></output>
<sample_input><![CDATA[4
aacc]]></sample_input>
<sample_output><![CDATA[aacc
acac
acca
caac
caca
ccaa
6]]></sample_output>
  <hint><![CDATA[]]></hint>
<source><![CDATA[算法设计-复杂算法]]></source>
		<solution language="C"><![CDATA[#include <stdio.h>
#define max 500
 int  count=0;
int repeat(char str[],int a ,int b )
 {
  int i;
          if(b>a)
           for(i=a;i<b;i++)
              if(str[i]==str[b])
                  return 0;
           return 1;
}


 void perm(char str[],int k,int m)
 {
           int i;
           if(k==m)
           {
              count++;
              for(i=0;i<=m;i++)
                  printf("%c",str[i]);
              printf("\n");
              return ;
           }
           else for(i=k;i<=m;i++)
                   if(repeat(str,k,i))
                   {
                          char t;
						  t=str[i];
						  str[i]=str[k];
						  str[k]=t;
                           perm(str,k+1,m);
                           t=str[i];
						   str[i]=str[k];
						  str[k]=t;
                   }
   
 }
 int main()
 {
      char str[max];
      int n,i;
	  scanf("%d",&n);
      getchar();
      for(i=0;i<n;i++)
          scanf("%c",&str[i]);
      perm(str,0,n-1) ;
      printf("%d\n",count);
      return 0;
 }]]></solution>
			<solution language="C++"><![CDATA[#include <iostream>

#include <algorithm>

using   namespace std ;

long ans ;

int ok(char str[],int a ,int b )

{

        if( b > a)

         for(int i = a ; i< b ; i++)

                 if( str[i] == str[b] )

                         return 0 ;

         return 1 ;

}

void perm(char str[],int k ,int m)

{

         int i ;

         if( k == m )

         {

                 ans ++ ;

                 for( i = 0 ;i <= m ;i++ )

                 {

                         cout<<str[i];

                 }

                 cout<<endl;

         }

         else  

    for( i = k ; i <= m ;i++)

                 if( ok(str,k,i) )

                 {

                         swap ( str[k],str[i] );

                         perm(str, k+1 , m );

                         swap(str[k],str[i] ) ;

                 }

         

}

int main(int argc, char* argv[])

{

   char str[1000];

   int n , i ;

   cin>>n ;

    ans = 0 ;

    for( i = 0 ; i < n ;  i ++)

  cin>>str[i];

    perm(str,0,n-1) ;

    cout<<ans<<endl;

         return 0;

}
]]></solution>
			<solution language="Java"><![CDATA[

import java.awt.List;
import java.util.Scanner;

/**
 *
 * @author wanshuzhen
 */ 

public class Main {
    public static int ans=0;
    public static void main(String[] args)
    {
       
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        char [] list = new char[n];
        list = sc.next().toCharArray();
        perm(list, 0, n-1);
       // System.out.print("输出序列为：");
        System.out.println(ans);
    }
    public static void perm(char []list ,int k, int m)
    {
        if(k==m)
        {
            ans++;
            for (int i=0;i<=m;i++){
                System.out.print(list[i]);
            }
            System.out.println();
        }
        else{
            for(int i=k;i<=m;i++)
                if(ok(list,k,i)){
                    swap(list,k,i);
                    perm(list, k+1, m);
                    swap(list,k,i);
                }
        }
    }
    public  static boolean ok(char []list,int k,int i){
        if(i>k)for(int t=k;t<i;t++)if(list[t]==list[i])return false;
        return true;
    }
    public static  void swap(char []list ,int i,int j){
        char temp;
        temp= list[i];
        list[i]=list[j];
        list[j]=temp;
        
    }
}
]]></solution>
	</item>
</fps>
